<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. Cache的访问 &mdash; GPGPU-Sim User Manual v1.0.0 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a3258c64" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=12f31cd9"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../_static/translations.js?v=beaddf03"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="prev" title="Welcome to GPGPU-Sim User Manual’s documentation!" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            GPGPU-Sim User Manual
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Cache的访问</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cache-basic-knowledge">1.1. Cache 基础</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cache-block">1.1.1. Cache Block 的组织方式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cache-block-addrmap">1.1.2. 访存地址的映射</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tag">1.1.2.1. Tag 位的计算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-address">1.1.2.2. Block Address 的计算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-index">1.1.2.3. Set Index 位的计算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">1.1.2.4. 访问地址的映射示意图</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cache-block-status">1.1.3. Cache Block的状态</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">1.2. Cache 的访问状态</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">1.3. Cache 的组织和实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">1.4. Cache 的访问状态</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GPGPU-Sim User Manual</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">1. </span>Cache的访问</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cache">
<span id="cache-access"></span><h1><span class="section-number">1. </span>Cache的访问<a class="headerlink" href="#cache" title="Link to this heading"></a></h1>
<p>Cache作为一种高速存储资源，通过存储近期或频繁访问的数据，极大地减少了处理器与主存之间的数据传输时间，从而提升了系统的整体性能。本章主要介绍 GPGPU-Sim 如何模拟对 Cache 的访问过程。</p>
<section id="cache-basic-knowledge">
<span id="id1"></span><h2><span class="section-number">1.1. </span>Cache 基础<a class="headerlink" href="#cache-basic-knowledge" title="Link to this heading"></a></h2>
<p>首先需要了解的就是 <cite>Sector Cache</cite> 和 <cite>Line Cache</cite> 的 <a class="reference internal" href="#cache-block-org"><span class="std std-ref">Cache Block 的组织方式</span></a>、 <a class="reference internal" href="#cache-block-addrmap"><span class="std std-ref">访存地址的映射</span></a> 以及 <a class="reference internal" href="#cache-block-status"><span class="std std-ref">Cache Block的状态</span></a>。</p>
<section id="cache-block">
<span id="cache-block-org"></span><h3><span class="section-number">1.1.1. </span>Cache Block 的组织方式<a class="headerlink" href="#cache-block" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><cite>Line Cache</cite>：Line Cache是最常见的缓存组织方式之一，它按固定大小的cache block来存储数据。这些行的大小取决于具体的GPU型号，在模拟器中的  <span class="xref std std-ref">Cache-Config</span> 中进行配置。当LDST单元尝试读取或写入数据时，整个cache block（包含所需数据的那部分）被加载到缓存中。因为程序往往具有良好的空间局部性，即接近已访问数据的其他数据很可能很快会被访问，行缓存可以有效利用这一点，提高缓存命中率，从而提高整体性能。</p></li>
<li><p><cite>Sector Cache</cite>：与Line Cache相比，Sector Cache提供了一种更为灵活的缓存数据方式。在Sector Cache中，每个cache block被进一步细分为若干个sector或称为“扇区”。这样，当请求特定数据时，只有包含这些数据的特定扇区会被加载到缓存中，而不是整个cache block。这种方法在数据的空间局部性不是非常理想的情况下尤其有效，因为它减少了不必要数据的缓存，从而为其他数据的缓存留出了空间，提高了缓存的有效性。</p></li>
</ul>
<p>下面的代码块 <a class="reference internal" href="#fig-cache-block-org"><span class="std std-ref">Cache Block的组织形式</span></a> 用一个 <cite>4</cite>-sets/<cite>6</cite>-ways 的简单Cache展示了Cache Block的两种组织形式。</p>
<div class="literal-block-wrapper docutils container" id="fig-cache-block-org">
<div class="code-block-caption"><span class="caption-number">列表 1.1 </span><span class="caption-text">Cache Block的组织形式</span><a class="headerlink" href="#fig-cache-block-org" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="c1">// 1. 如果是 Line Cache：</span>
<span class="linenos"> 1</span><span class="c1">//  4 sets, 6 ways, cache blocks are not split to sectors.</span>
<span class="linenos"> 2</span><span class="c1">//  |-----------------------------------|</span>
<span class="linenos"> 3</span><span class="c1">//  |  0  |  1  |  2  |  3  |  4  |  5  |  // set_index 0</span>
<span class="linenos"> 4</span><span class="c1">//  |-----------------------------------|</span>
<span class="linenos"> 5</span><span class="c1">//  |  6  |  7  |  8  |  9  |  10 |  11 |  // set_index 1</span>
<span class="linenos"> 6</span><span class="c1">//  |-----------------------------------|</span>
<span class="linenos"> 7</span><span class="c1">//  |  12 |  13 |  14 |  15 |  16 |  17 |  // set_index 2</span>
<span class="linenos"> 8</span><span class="c1">//  |-----------------------------------|</span>
<span class="linenos"> 9</span><span class="c1">//  |  18 |  19 |  20 |  21 |  22 |  23 |  // set_index 3</span>
<span class="linenos">10</span><span class="c1">//  |--------------|--------------------|</span>
<span class="linenos">11</span><span class="c1">//                 |--------&gt; 20 is the cache block index</span>
<span class="linenos">12</span><span class="c1">// 2. 如果是 Sector Cache：</span>
<span class="linenos">13</span><span class="c1">//  4 sets, 6 ways, each cache block is split to 4 sectors.</span>
<span class="linenos">14</span><span class="c1">//  |-----------------------------------|</span>
<span class="linenos">15</span><span class="c1">//  |  0  |  1  |  2  |  3  |  4  |  5  |  // set_index 0</span>
<span class="linenos">16</span><span class="c1">//  |-----------------------------------|</span>
<span class="linenos">17</span><span class="c1">//  |  6  |  7  |  8  |  9  |  10 |  11 |  // set_index 1</span>
<span class="linenos">18</span><span class="c1">//  |-----------------------------------|</span>
<span class="linenos">19</span><span class="c1">//  |  12 |  13 |  14 |  15 |  16 |  17 |  // set_index 2</span>
<span class="linenos">20</span><span class="c1">//  |-----------------------------------|</span>
<span class="linenos">21</span><span class="c1">//  |  18 |  19 |  20 |  21 |  22 |  23 |  // set_index 3</span>
<span class="linenos">22</span><span class="c1">//  |-----------/-----\-----------------|</span>
<span class="linenos">23</span><span class="c1">//             /       \</span>
<span class="linenos">24</span><span class="c1">//            /         \--------&gt; 20 is the cache block index</span>
<span class="linenos">25</span><span class="c1">//           /           \</span>
<span class="linenos">26</span><span class="c1">//          /             \</span>
<span class="linenos">27</span><span class="c1">//         |---------------|</span>
<span class="linenos">28</span><span class="c1">//         | 3 | 2 | 1 | 0 | // a block contains 4 sectors</span>
<span class="linenos">29</span><span class="c1">//         |---------|-----|</span>
<span class="linenos">30</span><span class="c1">//                   |--------&gt; 1 is the sector offset in the 20-th cache block</span>
</pre></div>
</div>
</div>
</section>
<section id="cache-block-addrmap">
<span id="id2"></span><h3><span class="section-number">1.1.2. </span>访存地址的映射<a class="headerlink" href="#cache-block-addrmap" title="Link to this heading"></a></h3>
<p>本节主要介绍一个访存地址如何映射到一个 cache block。如何将一个特定的访存地址映射到这些 cache block 上，是通过一系列精确计算的步骤完成的。其中最关键的两步是计算 <cite>Tag 位`</cite> 和 <cite>Set Index 位</cite>。 <cite>Tag 位</cite> 用于标识数据存储在哪个缓存块中，而 <cite>Set Index 位</cite> 则用于确定这个地址映射到缓存中的哪一个 Set 上。不过，即使能够确定一个地址映射到了哪个 Set，要找到这个数据是否已经被缓存（以及具体存储在哪一路），还需进行遍历查找，这一步是判断缓存命中还是缓存失效的关键环节。接下来，将详细介绍 <cite>Tag 位</cite> 和 <cite>Set Index 位</cite> 的计算过程，这两者是理解地址映射机制的重点。</p>
<section id="tag">
<h4><span class="section-number">1.1.2.1. </span>Tag 位的计算<a class="headerlink" href="#tag" title="Link to this heading"></a></h4>
<p>下面的代码块 <a class="reference internal" href="#fig-tag-calc"><span class="std std-ref">Tag 位的计算</span></a> 展示了如何由访存地址 <cite>addr</cite> 计算 <cite>tag 位</cite>。</p>
<p>这里需要注意的是，最新版本中的 GPGPU-Sim 中的 <cite>tag 位</cite> 是由 <cite>index 位</cite> 和 <cite>traditional tag 位</cite> 共同组成的（这里所说的 <cite>traditional tag 位</cite> 就是指传统 CPU 上 Cache 的 <cite>tag 位</cite> 的计算方式： <code class="docutils literal notranslate"><span class="pre">traditional</span> <span class="pre">tag</span> <span class="pre">=</span> <span class="pre">addr</span> <span class="pre">&gt;&gt;</span> <span class="pre">(log2(m_line_sz)</span> <span class="pre">+</span> <span class="pre">log2(m_nset))</span></code>，详见 <a class="reference internal" href="#fig-cache-block-addrmap"><span class="std std-ref">Cache Block的地址映射</span></a> 示意图），其中 <cite>m_line_sz</cite> 和 <cite>m_nset</cite> 分别是 Cache 的 <cite>line size</cite> 和 <cite>set</cite> 的数量），这样可以允许更复杂的 <cite>set index 位</cite> 的计算，从而避免将 <cite>set index 位</cite> 不同但是 <cite>traditional tag 位</cite> 相同的地址映射到同一个 <cite>set</cite>。这里是把完整的 [<cite>traditional tag 位 + set index 位 + log2(m_line_sz)’b0</cite>] 来作为 <cite>tag 位</cite>。</p>
<div class="literal-block-wrapper docutils container" id="fig-tag-calc">
<div class="code-block-caption"><span class="caption-number">列表 1.2 </span><span class="caption-text">Tag 位的计算</span><a class="headerlink" href="#fig-tag-calc" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">0</span><span class="k">typedef</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">new_addr_type</span><span class="p">;</span>
<span class="linenos">1</span>
<span class="linenos">2</span><span class="c1">// m_line_sz：cache block的大小，单位是字节。</span>
<span class="linenos">3</span><span class="n">new_addr_type</span><span class="w"> </span><span class="nf">tag</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">4</span><span class="w">  </span><span class="c1">// For generality, the tag includes both index and tag. This allows for more</span>
<span class="linenos">5</span><span class="w">  </span><span class="c1">// complex set index calculations that can result in different indexes</span>
<span class="linenos">6</span><span class="w">  </span><span class="c1">// mapping to the same set, thus the full tag + index is required to check</span>
<span class="linenos">7</span><span class="w">  </span><span class="c1">// for hit/miss. Tag is now identical to the block address.</span>
<span class="linenos">8</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">new_addr_type</span><span class="p">)(</span><span class="n">m_line_sz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="linenos">9</span><span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="block-address">
<h4><span class="section-number">1.1.2.2. </span>Block Address 的计算<a class="headerlink" href="#block-address" title="Link to this heading"></a></h4>
<div class="literal-block-wrapper docutils container" id="fig-block-addr-calc">
<div class="code-block-caption"><span class="caption-number">列表 1.3 </span><span class="caption-text">Block Address 的计算</span><a class="headerlink" href="#fig-block-addr-calc" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">0</span><span class="c1">// m_line_sz：cache block的大小，单位是字节。</span>
<span class="linenos">1</span><span class="n">new_addr_type</span><span class="w"> </span><span class="nf">block_addr</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">new_addr_type</span><span class="p">)(</span><span class="n">m_line_sz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="linenos">3</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>Block Address 的计算与 Tag 位的计算是一样的，都是通过 <cite>m_line_sz</cite> 来计算的。<cite>block_addr</cite> 函数会返回一个地址 <cite>addr</cite> 在 Cache 中的 <cite>block address</cite>，这里是把完整的 [<cite>traditional tag 位 + set index 位 + log2(m_line_sz)’b0</cite>] 来作为 <cite>tag 位</cite>。</p>
</section>
<section id="set-index">
<h4><span class="section-number">1.1.2.3. </span>Set Index 位的计算<a class="headerlink" href="#set-index" title="Link to this heading"></a></h4>
<p>GPGPU-Sim 中真正实现的 <cite>set index 位</cite> 的计算方式是通过 <cite>cache_config::set_index()</cite> 和 <cite>l2_cache_config::set_index()</cite> 函数来实现的，这个函数会返回一个地址 <cite>addr</cite> 在 Cache 中的 <cite>set index</cite>。这里的 <cite>set index</cite> 有一整套的映射函数，尤其是 L2 Cache 的映射方法十分复杂（涉及到内存子分区的概念），这里先不展开讨论。对于 L2 Cache 暂时只需要知道， <cite>set_index()</cite> 函数会计算并返回一个地址 <cite>addr</cite> 在 Cache 中的 <cite>set index</cite>，具体如何映射后续再讲。</p>
<p>这里仅介绍一下 GV100 架构中的 L1D Cache 的 <cite>set index 位</cite> 的计算方式，如 <a class="reference internal" href="#fig-set-index-calc"><span class="std std-ref">GV100 架构中的 L1D Cache 的 Set Index 位的计算</span></a> 所示：</p>
<div class="literal-block-wrapper docutils container" id="fig-set-index-calc">
<div class="code-block-caption"><span class="caption-number">列表 1.4 </span><span class="caption-text">GV100 架构中的 L1D Cache 的 Set Index 位的计算</span><a class="headerlink" href="#fig-set-index-calc" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="c1">// m_nset：cache set 的数量。</span>
<span class="linenos"> 1</span><span class="c1">// m_line_sz_log2：cache block 的大小的对数。</span>
<span class="linenos"> 2</span><span class="c1">// m_nset_log2：cache set 的数量的对数。</span>
<span class="linenos"> 3</span><span class="c1">// m_index_function：set index 的计算函数，GV100 架构中的 L1D Cache 的配置为</span>
<span class="linenos"> 4</span><span class="c1">//                   LINEAR_SET_FUNCTION。</span>
<span class="linenos"> 5</span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">cache_config::hash_function</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">m_nset</span><span class="p">,</span>
<span class="linenos"> 6</span><span class="w">                                     </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">m_line_sz_log2</span><span class="p">,</span>
<span class="linenos"> 7</span><span class="w">                                     </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">m_nset_log2</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">                                     </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">m_index_function</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">set_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">10</span><span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">m_index_function</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">    </span><span class="c1">// ......</span>
<span class="linenos">12</span><span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">LINEAR_SET_FUNCTION</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">13</span><span class="w">      </span><span class="c1">// addr: [m_line_sz_log2-1:0]                          =&gt; byte offset</span>
<span class="linenos">14</span><span class="w">      </span><span class="c1">// addr: [m_line_sz_log2+m_nset_log2-1:m_line_sz_log2] =&gt; set index</span>
<span class="linenos">15</span><span class="w">      </span><span class="n">set_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m_line_sz_log2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m_nset</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="linenos">16</span><span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="linenos">17</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">18</span><span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">19</span><span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Undefined set index function.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="linenos">20</span><span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="linenos">21</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">22</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">23</span><span class="w">  </span><span class="n">assert</span><span class="p">((</span><span class="n">set_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_nset</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos">24</span><span class="w">         </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Error: Set index out of bounds. This is caused by &quot;</span>
<span class="linenos">25</span><span class="w">         </span><span class="s">&quot;an incorrect or unimplemented custom set index function.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos">26</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">set_index</span><span class="p">;</span>
<span class="linenos">27</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><cite>Set Index 位</cite> 有一整套的映射函数，这里只是简单介绍了 GV100 架构中的 L1D Cache 的 <cite>Set Index 位</cite> 的计算结果，具体的映射函数会在后续章节中详细介绍。</p>
</div>
</section>
<section id="id3">
<h4><span class="section-number">1.1.2.4. </span>访问地址的映射示意图<a class="headerlink" href="#id3" title="Link to this heading"></a></h4>
<p>下面的代码块 <a class="reference internal" href="#fig-cache-block-addrmap"><span class="std std-ref">Cache Block的地址映射</span></a> 用一个访存地址 <cite>addr</cite> 展示了访问 Cache 的地址映射。</p>
<div class="literal-block-wrapper docutils container" id="fig-cache-block-addrmap">
<div class="code-block-caption"><span class="caption-number">列表 1.5 </span><span class="caption-text">Cache Block的地址映射</span><a class="headerlink" href="#fig-cache-block-addrmap" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="c1">// 1. 如果是 Line Cache：</span>
<span class="linenos"> 1</span><span class="c1">//  MSHR 的地址即为地址 addr 的 [tag 位 + set_index 位]。即除 offset in-line</span>
<span class="linenos"> 2</span><span class="c1">//  位以外的所有位。</span>
<span class="linenos"> 3</span><span class="c1">//  |&lt;----mshr_addr---&gt;|</span>
<span class="linenos"> 4</span><span class="c1">//                              line offset</span>
<span class="linenos"> 5</span><span class="c1">//                     |-------------------------|</span>
<span class="linenos"> 6</span><span class="c1">//                      \                       /</span>
<span class="linenos"> 7</span><span class="c1">//  |&lt;-Tr--&gt;|            \                     /</span>
<span class="linenos"> 8</span><span class="c1">//  |-------|-------------|-------------------| // addr</span>
<span class="linenos"> 9</span><span class="c1">//             set_index     offset in-line</span>
<span class="linenos">10</span><span class="c1">//  |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 0 0 0|</span>
<span class="linenos">11</span><span class="c1">// 2. 如果是 Sector Cache：</span>
<span class="linenos">12</span><span class="c1">//  MSHR 的地址即为地址 addr 的 [tag 位 + set_index 位 + sector offset 位]。</span>
<span class="linenos">13</span><span class="c1">//  即除 offset in-sector 位以外的所有位。</span>
<span class="linenos">14</span><span class="c1">//  |&lt;----------mshr_addr-----------&gt;|</span>
<span class="linenos">15</span><span class="c1">//                     sector offset  offset in-sector</span>
<span class="linenos">16</span><span class="c1">//                     |-------------|-----------|</span>
<span class="linenos">17</span><span class="c1">//                      \                       /</span>
<span class="linenos">18</span><span class="c1">//  |&lt;-Tr--&gt;|            \                     /</span>
<span class="linenos">19</span><span class="c1">//  |-------|-------------|-------------------| // addr</span>
<span class="linenos">20</span><span class="c1">//             set_index     offset in-line</span>
<span class="linenos">21</span><span class="c1">//  |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 0 0 0|</span>
</pre></div>
</div>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p><a class="reference internal" href="#fig-cache-block-addrmap"><span class="std std-ref">Cache Block的地址映射</span></a> 中所展示的是最新版本 GPGPU-Sim 的实现， <cite>tag 位</cite> 是由 <cite>index 位</cite> 和 <cite>traditional tag 位</cite> 共同组成的。 <cite>traditional tag 位</cite> 如图中 <cite>Tr</cite> 的范围所示。</p>
</div>
</section>
</section>
<section id="cache-block-status">
<span id="id4"></span><h3><span class="section-number">1.1.3. </span>Cache Block的状态<a class="headerlink" href="#cache-block-status" title="Link to this heading"></a></h3>
<p>Cache Block 的状态是指在 Line Cache 中 cache block 或者在 Sector Cache 中的 cache sector 的状态，包含以下几种：</p>
<div class="literal-block-wrapper docutils container" id="code-cache-block-status">
<div class="code-block-caption"><span class="caption-number">列表 1.6 </span><span class="caption-text">Cache Block State</span><a class="headerlink" href="#code-cache-block-status" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">0</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_block_state</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">INVALID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">RESERVED</span><span class="p">,</span><span class="w"> </span><span class="n">VALID</span><span class="p">,</span><span class="w"> </span><span class="n">MODIFIED</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
</div>
<p>这里会区分开 Line Cache 和 Sector Cache 的状态介绍，因为 Line Cache 和 Sector Cache 的状态是不同的。对于 Line Cache 来说，每个 <code class="docutils literal notranslate"><span class="pre">line_cache_block</span> <span class="pre">*line</span></code> 对象都有一个标识状态的成员变量 <code class="docutils literal notranslate"><span class="pre">m_status</span></code>，它的值是 <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cache_block_state</span></code> 中的一种。具体的状态如下：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">INVALID</span></code>: cache block 无效数据。需要注意的是，这里的无效与下面的 <code class="docutils literal notranslate"><span class="pre">MODIFIED</span></code> 和 <code class="docutils literal notranslate"><span class="pre">RESERVED</span></code> 不同，意味着当前 cache block 没有存储任何有效数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VALID</span></code>: 当一个 cache block 的状态是 <code class="docutils literal notranslate"><span class="pre">VALID</span></code>，说明该 block 的数据是有效的，可以为 cache 提供命中的数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MODIFIED</span></code>: 如果 cache block 状态是 <code class="docutils literal notranslate"><span class="pre">MODIFIED</span></code>，说明该 block 的数据已经被其他线程修改。如果当前访问也是写操作的话即为命中；但如果不是写操作，则需要判断当前 cache block 是否已被修改完毕并可读（由 <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">m_readable</span></code> 确定），修改完毕并可读的话（<code class="docutils literal notranslate"><span class="pre">m_readable</span> <span class="pre">=</span> <span class="pre">true</span></code>）则为命中，不可读的话（<code class="docutils literal notranslate"><span class="pre">m_readable</span> <span class="pre">=</span> <span class="pre">false</span></code>）则发生  <code class="docutils literal notranslate"><span class="pre">SECTOR_MISS</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RESERVED</span></code>: 当一个 cache block 被分配以重新填充未命中的数据，即需要装入新的数据以应对未命中（<code class="docutils literal notranslate"><span class="pre">MISS</span></code>）情况时（如果一次数据访问 cache 或者一个数据填充进 cache 时发生 <code class="docutils literal notranslate"><span class="pre">MISS</span></code>），cache block 的状态 <code class="docutils literal notranslate"><span class="pre">m_status</span></code> 被设置为 <code class="docutils literal notranslate"><span class="pre">RESERVED</span></code>，这意味着该 block 正在准备或已经准备好重新填充新的数据。</p></li>
</ul>
<p>而对于 Sector Cache 来说，每个 <code class="docutils literal notranslate"><span class="pre">sector_cache_block_t</span> <span class="pre">*line</span></code> 对象都有一个 <code class="docutils literal notranslate"><span class="pre">cache_block_state</span> <span class="pre">*m_status</span></code> 数组。数组的大小是 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">SECTOR_CHUNCK_SIZE</span> <span class="pre">=</span> <span class="pre">4</span></code> 即每个 cache line 都有 <cite>4</cite> 个 sector，这个状态数组用以标识每个 sector 的状态，它的每一个元素也都是 <code class="docutils literal notranslate"><span class="pre">cache_block_state</span></code> 中的一个。具体的状态与上述 Line Cache 中的状态的唯一区别就是，<code class="docutils literal notranslate"><span class="pre">cache_block_state</span> <span class="pre">*m_status</span></code> 数组的每个元素标识每个 sector 的状态，而不是 Line Cache 中的整个 cache block 的状态。</p>
</section>
</section>
<section id="id5">
<h2><span class="section-number">1.2. </span>Cache 的访问状态<a class="headerlink" href="#id5" title="Link to this heading"></a></h2>
<p>Cache 的访问状态有以下几种：</p>
<div class="literal-block-wrapper docutils container" id="code-cache-request-status">
<div class="code-block-caption"><span class="caption-number">列表 1.7 </span><span class="caption-text">Cache Request Status</span><a class="headerlink" href="#code-cache-request-status" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 1</span><span class="w">  </span><span class="c1">// 命中。</span>
<span class="linenos"> 2</span><span class="w">  </span><span class="n">HIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="linenos"> 3</span><span class="w">  </span><span class="c1">// 保留成功，当访问地址被映射到一个已经被分配的 cache block/sector 时，block/</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="c1">// sector 的状态被设置为 RESERVED。</span>
<span class="linenos"> 5</span><span class="w">  </span><span class="n">HIT_RESERVED</span><span class="p">,</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="c1">// 未命中。</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="n">MISS</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="c1">// 保留失败。</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="n">RESERVATION_FAIL</span><span class="p">,</span>
<span class="linenos">10</span><span class="w">  </span><span class="c1">// Sector缺失。</span>
<span class="linenos">11</span><span class="w">  </span><span class="n">SECTOR_MISS</span><span class="p">,</span>
<span class="linenos">12</span><span class="w">  </span><span class="n">MSHR_HIT</span><span class="p">,</span>
<span class="linenos">13</span><span class="w">  </span><span class="c1">// cache_request_status的状态总数。</span>
<span class="linenos">14</span><span class="w">  </span><span class="n">NUM_CACHE_REQUEST_STATUS</span>
<span class="linenos">15</span><span class="p">};</span>
</pre></div>
</div>
</div>
</section>
<section id="id6">
<h2><span class="section-number">1.3. </span>Cache 的组织和实现<a class="headerlink" href="#id6" title="Link to this heading"></a></h2>
<p>TODO</p>
</section>
<section id="id7">
<h2><span class="section-number">1.4. </span>Cache 的访问状态<a class="headerlink" href="#id7" title="Link to this heading"></a></h2>
<p>在访问 Cache 的时候，会调用 <code class="docutils literal notranslate"><span class="pre">access()</span></code> 函数，例如 <code class="docutils literal notranslate"><span class="pre">m_L2cache-&gt;access()</span></code>，<code class="docutils literal notranslate"><span class="pre">m_L1I-&gt;access()</span></code>，<code class="docutils literal notranslate"><span class="pre">m_L1D-&gt;access()</span></code> 等。</p>
<p><code class="docutils literal notranslate"><span class="pre">access()</span></code> 函数主要完成以下几个步骤：</p>
<ul class="simple">
<li><p>计算地址 <code class="docutils literal notranslate"><span class="pre">addr</span></code> 映射到 Cache 的 Block 地址 <code class="docutils literal notranslate"><span class="pre">new_addr_type</span> <span class="pre">block_addr</span></code>。</p></li>
<li><p>根据 <code class="docutils literal notranslate"><span class="pre">new_addr_type</span> <span class="pre">block_addr</span></code> 和访问 Cache 的数据包 <code class="docutils literal notranslate"><span class="pre">mem_fetch</span> <span class="pre">*mf</span></code> 判断访问 Cache 的返回状态。</p></li>
<li><p>根据返回状态执行相应的操作，包括：<code class="docutils literal notranslate"><span class="pre">m_wr_hit</span></code>、<code class="docutils literal notranslate"><span class="pre">m_wr_miss</span></code>、<code class="docutils literal notranslate"><span class="pre">m_rd_hit</span></code>、<code class="docutils literal notranslate"><span class="pre">m_rd_miss</span></code>。</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="code-cache-access-function">
<div class="code-block-caption"><span class="caption-number">列表 1.8 </span><span class="caption-text">Data Cache Access Function</span><a class="headerlink" href="#code-cache-access-function" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::access</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span>
<span class="linenos"> 1</span><span class="w">                                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 2</span><span class="w">                                             </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 3</span><span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_data_size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">get_atom_sz</span><span class="p">());</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">wr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_is_write</span><span class="p">();</span>
<span class="linenos"> 5</span><span class="w">  </span><span class="c1">// Block Address 的计算与 Tag 位的计算是一样的，都是通过 m_line_sz 来计算的。</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="c1">// block_addr 函数会返回一个地址 addr 在 Cache 中的 block address，这里是把</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="c1">// 完整的 [traditional tag 位 + set index 位 + log2(m_line_sz)&#39;b0] 来作为</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="c1">// tag 位。</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="mi">-1</span><span class="p">;</span>
<span class="linenos">12</span><span class="w">  </span><span class="c1">// 判断对 cache 的访问（地址为 addr）是 HIT / HIT_RESERVED / SECTOR_MISS /</span>
<span class="linenos">13</span><span class="w">  </span><span class="c1">// MISS / RESERVATION_FAIL 等状态。且如果返回的 cache 访问为 MISS，则将需要</span>
<span class="linenos">14</span><span class="w">  </span><span class="c1">// 被替换的 cache block 的索引写入 cache_index。</span>
<span class="linenos">15</span><span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">probe_status</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">16</span><span class="w">      </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">is_write</span><span class="p">(),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="linenos">17</span><span class="w">  </span><span class="c1">// 主要包括上述各种对 cache 的访问的状态下的执行对 cache 访问的操作，例如：</span>
<span class="linenos">18</span><span class="w">  </span><span class="c1">//   (this-&gt;*m_wr_hit)、(this-&gt;*m_wr_miss)、</span>
<span class="linenos">19</span><span class="w">  </span><span class="c1">//   (this-&gt;*m_rd_hit)、(this-&gt;*m_rd_miss)。</span>
<span class="linenos">20</span><span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">access_status</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">21</span><span class="w">      </span><span class="n">process_tag_probe</span><span class="p">(</span><span class="n">wr</span><span class="p">,</span><span class="w"> </span><span class="n">probe_status</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">22</span><span class="w">  </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span>
<span class="linenos">23</span><span class="w">                    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">select_stats_status</span><span class="p">(</span><span class="n">probe_status</span><span class="p">,</span><span class="w"> </span><span class="n">access_status</span><span class="p">));</span>
<span class="linenos">24</span><span class="w">  </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_stats_pw</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">m_stats</span><span class="p">.</span><span class="n">select_stats_status</span><span class="p">(</span>
<span class="linenos">25</span><span class="w">                                                  </span><span class="n">probe_status</span><span class="p">,</span><span class="w"> </span><span class="n">access_status</span><span class="p">));</span>
<span class="linenos">26</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">access_status</span><span class="p">;</span>
<span class="linenos">27</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-cache-tag-array-probe">
<div class="code-block-caption"><span class="caption-number">列表 1.9 </span><span class="caption-text">tag_array::probe() 函数</span><a class="headerlink" href="#code-cache-tag-array-probe" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">  0</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">tag_array::probe</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">&amp;</span><span class="n">idx</span><span class="p">,</span>
<span class="linenos">  1</span><span class="w">                                           </span><span class="n">mem_access_sector_mask_t</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span>
<span class="linenos">  2</span><span class="w">                                           </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_write</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">probe_mode</span><span class="p">,</span>
<span class="linenos">  3</span><span class="w">                                           </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">  4</span><span class="w">  </span><span class="c1">// 这里的输入地址 addr 是 cache block 的地址，该地址即为由 block_addr() 计算</span>
<span class="linenos">  5</span><span class="w">  </span><span class="c1">// 而来。</span>
<span class="linenos">  6</span><span class="w">  </span><span class="c1">// m_config.set_index(addr) 是返回一个地址 addr 在 Cache 中的 set index。这</span>
<span class="linenos">  7</span><span class="w">  </span><span class="c1">// 里的 set index 有一整套的映射函数。</span>
<span class="linenos">  8</span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">set_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos">  9</span><span class="w">  </span><span class="c1">// |-------|-------------|--------------|</span>
<span class="linenos"> 10</span><span class="w">  </span><span class="c1">//            set_index   offset in-line</span>
<span class="linenos"> 11</span><span class="w">  </span><span class="c1">// |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 |</span>
<span class="linenos"> 12</span><span class="w">  </span><span class="c1">// 这里实际返回的是 {除 offset in-line 以外的所有位, offset in-line&#39;b0}，即</span>
<span class="linenos"> 13</span><span class="w">  </span><span class="c1">// set index 也作为 tag 位的一部分了。</span>
<span class="linenos"> 14</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">tag</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos"> 15</span>
<span class="linenos"> 16</span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">invalid_line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="mi">-1</span><span class="p">;</span>
<span class="linenos"> 17</span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">valid_line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="mi">-1</span><span class="p">;</span>
<span class="linenos"> 18</span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">valid_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="mi">-1</span><span class="p">;</span>
<span class="linenos"> 19</span>
<span class="linenos"> 20</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">all_reserved</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos"> 21</span>
<span class="linenos"> 22</span><span class="w">  </span><span class="c1">// check for hit or pending hit</span>
<span class="linenos"> 23</span><span class="w">  </span><span class="c1">// 对所有的 Cache Ways 检查。需要注意这里其实是针对一个 set 的所有 way 进行检</span>
<span class="linenos"> 24</span><span class="w">  </span><span class="c1">// 查，因为给定一个地址，可以确定它所在的 set index，然后再通过 tag 位 来匹配</span>
<span class="linenos"> 25</span><span class="w">  </span><span class="c1">// 并确定这个地址在哪一个 way 上。</span>
<span class="linenos"> 26</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">way</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">way</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">m_assoc</span><span class="p">;</span><span class="w"> </span><span class="n">way</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 27</span><span class="w">    </span><span class="c1">// For example, 4 sets, 6 ways:</span>
<span class="linenos"> 28</span><span class="w">    </span><span class="c1">// |  0  |  1  |  2  |  3  |  4  |  5  |  // set_index 0</span>
<span class="linenos"> 29</span><span class="w">    </span><span class="c1">// |  6  |  7  |  8  |  9  |  10 |  11 |  // set_index 1</span>
<span class="linenos"> 30</span><span class="w">    </span><span class="c1">// |  12 |  13 |  14 |  15 |  16 |  17 |  // set_index 2</span>
<span class="linenos"> 31</span><span class="w">    </span><span class="c1">// |  18 |  19 |  20 |  21 |  22 |  23 |  // set_index 3</span>
<span class="linenos"> 32</span><span class="w">    </span><span class="c1">//                |--------&gt; index =&gt; cache_block_t *line</span>
<span class="linenos"> 33</span><span class="w">    </span><span class="c1">// index 是 cache block 的索引。</span>
<span class="linenos"> 34</span><span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">set_index</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">m_assoc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">way</span><span class="p">;</span>
<span class="linenos"> 35</span><span class="w">    </span><span class="n">cache_block_t</span><span class="w"> </span><span class="o">*</span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_lines</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="linenos"> 36</span><span class="w">    </span><span class="c1">// tag 位 相符，说明当前 cache block 已经是 addr 地址映射在当前 way 上。</span>
<span class="linenos"> 37</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">m_tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 38</span><span class="w">      </span><span class="c1">// cache block 的状态，包含：</span>
<span class="linenos"> 39</span><span class="w">      </span><span class="c1">//     enum cache_block_state {</span>
<span class="linenos"> 40</span><span class="w">      </span><span class="c1">//       INVALID = 0, RESERVED, VALID, MODIFIED };</span>
<span class="linenos"> 41</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_status</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RESERVED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 42</span><span class="w">        </span><span class="c1">// 当访问地址被映射到一个已经被分配的 cache block 或 cache sector 时，</span>
<span class="linenos"> 43</span><span class="w">        </span><span class="c1">// cache block 或 cache sector 的状态被设置为 RESERVED。这说明当前</span>
<span class="linenos"> 44</span><span class="w">        </span><span class="c1">// block / sector 被分配给了其他的线程，而且正在读取的内容正是访问地址</span>
<span class="linenos"> 45</span><span class="w">        </span><span class="c1">// addr 想要的数据。</span>
<span class="linenos"> 46</span><span class="w">        </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos"> 47</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">HIT_RESERVED</span><span class="p">;</span>
<span class="linenos"> 48</span><span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_status</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 49</span><span class="w">        </span><span class="c1">// 如果 cache block 或 cache sector 的状态是 VALID，说明已经命中。</span>
<span class="linenos"> 50</span><span class="w">        </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos"> 51</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">HIT</span><span class="p">;</span>
<span class="linenos"> 52</span><span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_status</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MODIFIED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 53</span><span class="w">        </span><span class="c1">// 如果 cache block 或 cache sector 的状态是 MODIFIED，说明该 block</span>
<span class="linenos"> 54</span><span class="w">        </span><span class="c1">// 或 sector 的数据已经被其他线程修改。如果当前访问也是写操作的话即为命</span>
<span class="linenos"> 55</span><span class="w">        </span><span class="c1">// 中；但如果不是写操作，则需要判断当前 cache block 或 cache sector</span>
<span class="linenos"> 56</span><span class="w">        </span><span class="c1">// 是否已被修改完毕并可读（由 ``bool m_readable`` 确定），修改完毕并可</span>
<span class="linenos"> 57</span><span class="w">        </span><span class="c1">// 读的话（``m_readable = true``）则为命中，不可读的话（``m_readable</span>
<span class="linenos"> 58</span><span class="w">        </span><span class="c1">// = false``）则发生 SECTOR_MISS。</span>
<span class="linenos"> 59</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="n">is_write</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">line</span><span class="o">-&gt;</span><span class="n">is_readable</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">is_write</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 60</span><span class="w">          </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos"> 61</span><span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">HIT</span><span class="p">;</span>
<span class="linenos"> 62</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 63</span><span class="w">          </span><span class="c1">// for condition: is_write &amp;&amp; line-&gt;is_readable(mask) == false.</span>
<span class="linenos"> 64</span><span class="w">          </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos"> 65</span><span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">SECTOR_MISS</span><span class="p">;</span>
<span class="linenos"> 66</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 67</span><span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">is_valid_line</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_status</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 68</span><span class="w">        </span><span class="c1">// line cache 不会走这个分支，在 line cache 中，line-&gt;is_valid_line()</span>
<span class="linenos"> 69</span><span class="w">        </span><span class="c1">// 返回的是 m_status 的值，当其为 VALID 时，line-&gt;get_status(mask) 也</span>
<span class="linenos"> 70</span><span class="w">        </span><span class="c1">// 是返回的 m_status 的值，即为 VALID，因此对于 line cache 这条分支无</span>
<span class="linenos"> 71</span><span class="w">        </span><span class="c1">// 效。但是对于sector cache， 有：</span>
<span class="linenos"> 72</span><span class="w">        </span><span class="c1">//   virtual bool is_valid_line() { return !(is_invalid_line()); }</span>
<span class="linenos"> 73</span><span class="w">        </span><span class="c1">// 而 sector cache 中的 is_invalid_line() 是，只要有一个 sector 不为</span>
<span class="linenos"> 74</span><span class="w">        </span><span class="c1">// INVALID 即返回 false，因此 is_valid_line() 返回的是，只要存在一个</span>
<span class="linenos"> 75</span><span class="w">        </span><span class="c1">// sector 不为 INVALID 就设置 is_valid_line() 为真。所以这条分支对于</span>
<span class="linenos"> 76</span><span class="w">        </span><span class="c1">// sector cache 是可走的。</span>
<span class="linenos"> 77</span><span class="w">        </span><span class="c1">// cache block 有效，但是其中的 byte mask = cache block[mask] 状态无</span>
<span class="linenos"> 78</span><span class="w">        </span><span class="c1">// 效，说明 sector 缺失。</span>
<span class="linenos"> 79</span><span class="w">        </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos"> 80</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SECTOR_MISS</span><span class="p">;</span>
<span class="linenos"> 81</span><span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 82</span><span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_status</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">INVALID</span><span class="p">);</span>
<span class="linenos"> 83</span><span class="w">      </span><span class="p">}</span>
<span class="linenos"> 84</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 85</span>
<span class="linenos"> 86</span><span class="w">    </span><span class="c1">// 每一次循环中能走到这里的，即为当前 cache block 的 line-&gt;m_tag != tag。</span>
<span class="linenos"> 87</span><span class="w">    </span><span class="c1">// 那么就需要考虑当前这 cache block 能否被逐出替换，请注意，这个判断是在对</span>
<span class="linenos"> 88</span><span class="w">    </span><span class="c1">// 每一个 way 循环的过程中进行的，也就是说，假如第一个 cache block 没有返</span>
<span class="linenos"> 89</span><span class="w">    </span><span class="c1">// 回以上访问状态，但有可能直到所有 way 的最后一个 cache block 才满足</span>
<span class="linenos"> 90</span><span class="w">    </span><span class="c1">// m_tag != tag，但是在对第 0 ~ way-2 号的 cache block 循环判断的时候，</span>
<span class="linenos"> 91</span><span class="w">    </span><span class="c1">// 就需要记录下每一个 way 的 cache block 是否能够被逐出。因为如果等到所有</span>
<span class="linenos"> 92</span><span class="w">    </span><span class="c1">// way 的 cache block 都没有满足 line-&gt;m_tag != tag 时，再回过头来循环所</span>
<span class="linenos"> 93</span><span class="w">    </span><span class="c1">// 有 way 找最优先被逐出的 cache block 那就增加了模拟的开销。因此实际上对</span>
<span class="linenos"> 94</span><span class="w">    </span><span class="c1">// 于所有 way 中的每一个 cache block，只要它不满足 line-&gt;m_tag != tag，</span>
<span class="linenos"> 95</span><span class="w">    </span><span class="c1">// 就在这里判断它能否被逐出。</span>
<span class="linenos"> 96</span><span class="w">    </span><span class="c1">// line-&gt;is_reserved_line()：只要有一个 sector 是 RESERVED，就认为这个</span>
<span class="linenos"> 97</span><span class="w">    </span><span class="c1">// Cache Line 是 RESERVED。这里即整个 line 没有 sector 是 RESERVED。</span>
<span class="linenos"> 98</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">is_reserved_line</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 99</span><span class="w">      </span><span class="c1">// percentage of dirty lines in the cache</span>
<span class="linenos">100</span><span class="w">      </span><span class="c1">// number of dirty lines / total lines in the cache</span>
<span class="linenos">101</span><span class="w">      </span><span class="kt">float</span><span class="w"> </span><span class="n">dirty_line_percentage</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">102</span><span class="w">          </span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">m_dirty</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_nset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">m_assoc</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="linenos">103</span><span class="w">      </span><span class="c1">// If the cacheline is from a load op (not modified),</span>
<span class="linenos">104</span><span class="w">      </span><span class="c1">// or the total dirty cacheline is above a specific value,</span>
<span class="linenos">105</span><span class="w">      </span><span class="c1">// Then this cacheline is eligible to be considered for replacement</span>
<span class="linenos">106</span><span class="w">      </span><span class="c1">// candidate, i.e. Only evict clean cachelines until total dirty</span>
<span class="linenos">107</span><span class="w">      </span><span class="c1">// cachelines reach the limit.</span>
<span class="linenos">108</span><span class="w">      </span><span class="c1">// m_config.m_wr_percent 在 V100 中配置为 25%。</span>
<span class="linenos">109</span><span class="w">      </span><span class="c1">// line-&gt;is_modified_line()：只要有一个 sector 是 MODIFIED，就认为这</span>
<span class="linenos">110</span><span class="w">      </span><span class="c1">// 个 cache line 是MODIFIED。这里即整个 line 没有 sector 是 MODIFIED，</span>
<span class="linenos">111</span><span class="w">      </span><span class="c1">// 或者 dirty_line_percentage 超过了 m_config.m_wr_percent。</span>
<span class="linenos">112</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">is_modified_line</span><span class="p">()</span><span class="w"> </span><span class="o">||</span>
<span class="linenos">113</span><span class="w">          </span><span class="n">dirty_line_percentage</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">m_wr_percent</span><span class="p">)</span>
<span class="linenos">114</span><span class="w">      </span><span class="p">{</span>
<span class="linenos">115</span><span class="w">        </span><span class="c1">// 因为在逐出一个 cache block 时，优先逐出一个干净的块，即没有 sector</span>
<span class="linenos">116</span><span class="w">        </span><span class="c1">// 被 RESERVED，也没有 sector 被 MODIFIED，来逐出；但是如果 dirty 的</span>
<span class="linenos">117</span><span class="w">        </span><span class="c1">// cache line 的比例超过 m_wr_percent（V100 中配置为 25%），也可以不</span>
<span class="linenos">118</span><span class="w">        </span><span class="c1">// 满足 MODIFIED 的条件。</span>
<span class="linenos">119</span><span class="w">        </span><span class="c1">// 在缓存管理机制中，优先逐出未被修改（&quot;干净&quot;）的缓存块的策略，是基于几</span>
<span class="linenos">120</span><span class="w">        </span><span class="c1">// 个重要的考虑：</span>
<span class="linenos">121</span><span class="w">        </span><span class="c1">// 1. 减少写回成本：缓存中的数据通常来源于更低速的后端存储（如主存储器）。</span>
<span class="linenos">122</span><span class="w">        </span><span class="c1">//    当缓存块被修改（即包含&quot;脏&quot;数据）时，在逐出这些块之前，需要将这些更</span>
<span class="linenos">123</span><span class="w">        </span><span class="c1">//    改写回到后端存储以确保数据一致性。相比之下，未被修改（&quot;干净&quot;）的缓</span>
<span class="linenos">124</span><span class="w">        </span><span class="c1">//    存块可以直接被逐出，因为它们的内容已经与后端存储一致，无需进行写回</span>
<span class="linenos">125</span><span class="w">        </span><span class="c1">//    操作。这样就避免了写回操作带来的时间和能量开销。</span>
<span class="linenos">126</span><span class="w">        </span><span class="c1">// 2. 提高效率：写回操作相对于读取操作来说，是一个成本较高的过程，不仅涉</span>
<span class="linenos">127</span><span class="w">        </span><span class="c1">//    及更多的时间延迟，还可能占用宝贵的带宽，影响系统的整体性能。通过先</span>
<span class="linenos">128</span><span class="w">        </span><span class="c1">//    逐出那些&quot;干净&quot;的块，系统能够在维持数据一致性的前提下，减少对后端存</span>
<span class="linenos">129</span><span class="w">        </span><span class="c1">//    储带宽的需求和写回操作的开销。</span>
<span class="linenos">130</span><span class="w">        </span><span class="c1">// 3. 优化性能：选择逐出&quot;干净&quot;的缓存块还有助于维护缓存的高命中率。理想情</span>
<span class="linenos">131</span><span class="w">        </span><span class="c1">//    况下，缓存应当存储访问频率高且最近被访问的数据。逐出&quot;脏&quot;数据意味着</span>
<span class="linenos">132</span><span class="w">        </span><span class="c1">//    这些数据需要被写回，这个过程不仅耗时而且可能导致缓存暂时无法服务其</span>
<span class="linenos">133</span><span class="w">        </span><span class="c1">//    他请求，从而降低缓存效率。</span>
<span class="linenos">134</span><span class="w">        </span><span class="c1">// 4. 数据安全与完整性：在某些情况下，&quot;脏&quot;缓存块可能表示正在进行的写操作</span>
<span class="linenos">135</span><span class="w">        </span><span class="c1">//    或者重要的数据更新。通过优先逐出&quot;干净&quot;的缓存块，可以降低因为缓存逐</span>
<span class="linenos">136</span><span class="w">        </span><span class="c1">//    出导致的数据丢失或者完整性破坏的风险。</span>
<span class="linenos">137</span>
<span class="linenos">138</span><span class="w">        </span><span class="c1">// all_reserved 被初始化为 true，是指所有 cache line 都没有能够逐出来</span>
<span class="linenos">139</span><span class="w">        </span><span class="c1">// 为新访问提供 RESERVE 的空间，这里一旦满足上面两个 if 条件，说明当前</span>
<span class="linenos">140</span><span class="w">        </span><span class="c1">// line 可以被逐出来提供空间供 RESERVE 新访问，这里 all_reserved 置为</span>
<span class="linenos">141</span><span class="w">        </span><span class="c1">// false。而一旦最终 all_reserved 仍旧保持 true 的话，就说明当前 set</span>
<span class="linenos">142</span><span class="w">        </span><span class="c1">// 里没有哪一个 way 的 cache block 可以被逐出，发生 RESERVATION_FAIL。</span>
<span class="linenos">143</span><span class="w">        </span><span class="n">all_reserved</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos">144</span><span class="w">        </span><span class="c1">// line-&gt;is_invalid_line() 标识所有 sector 都无效。</span>
<span class="linenos">145</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">is_invalid_line</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">146</span><span class="w">          </span><span class="c1">// 尽管配置有 LRU 或者 FIFO 替换策略，但是最理想的情况还是优先替换整个</span>
<span class="linenos">147</span><span class="w">          </span><span class="c1">// cache block 都无效的块。因为这种无效的块不需要写回，能够节省带宽。</span>
<span class="linenos">148</span><span class="w">          </span><span class="n">invalid_line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos">149</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">150</span><span class="w">          </span><span class="c1">// valid_line aims to keep track of most appropriate replacement</span>
<span class="linenos">151</span><span class="w">          </span><span class="c1">// candidate.</span>
<span class="linenos">152</span><span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_replacement_policy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LRU</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">153</span><span class="w">            </span><span class="c1">// valid_timestamp 设置为最近最少被使用的 cache line 的最末次访问</span>
<span class="linenos">154</span><span class="w">            </span><span class="c1">// 时间。</span>
<span class="linenos">155</span><span class="w">            </span><span class="c1">// valid_timestamp 被初始化为 (unsigned)-1，即可以看作无穷大。</span>
<span class="linenos">156</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_last_access_time</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">valid_timestamp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">157</span><span class="w">              </span><span class="c1">// 这里的 valid_timestamp 是周期数，即最小的周期数具有最大的被逐</span>
<span class="linenos">158</span><span class="w">              </span><span class="c1">// 出优先级，当然这个变量在这里只是找具有最小周期数的 cache block，</span>
<span class="linenos">159</span><span class="w">              </span><span class="c1">// 最小周期数意味着离他上次使用才最早，真正标识哪个 cache block</span>
<span class="linenos">160</span><span class="w">              </span><span class="c1">// 具有最大优先级被逐出的是valid_line。</span>
<span class="linenos">161</span><span class="w">              </span><span class="n">valid_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_last_access_time</span><span class="p">();</span>
<span class="linenos">162</span><span class="w">              </span><span class="c1">// 标识当前 cache block 具有最小的执行周期数，index 这个 cache</span>
<span class="linenos">163</span><span class="w">              </span><span class="c1">// block 应该最先被逐出。</span>
<span class="linenos">164</span><span class="w">              </span><span class="n">valid_line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos">165</span><span class="w">            </span><span class="p">}</span>
<span class="linenos">166</span><span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_replacement_policy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FIFO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">167</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_alloc_time</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">valid_timestamp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">168</span><span class="w">              </span><span class="c1">// FIFO 按照最早分配时间的 cache block 最优先被逐出的原则。</span>
<span class="linenos">169</span><span class="w">              </span><span class="n">valid_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="o">-&gt;</span><span class="n">get_alloc_time</span><span class="p">();</span>
<span class="linenos">170</span><span class="w">              </span><span class="n">valid_line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos">171</span><span class="w">            </span><span class="p">}</span>
<span class="linenos">172</span><span class="w">          </span><span class="p">}</span>
<span class="linenos">173</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">174</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">175</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// 这里是把当前 set 里所有的 way 都循环一遍，如果找到了 line-&gt;m_tag ==</span>
<span class="linenos">176</span><span class="w">      </span><span class="c1">// tag 的块，则已经返回了访问状态，如果没有找到，则也遍历了一遍所有 way 的</span>
<span class="linenos">177</span><span class="w">      </span><span class="c1">// cache block，找到了最优先应该被逐出和替换的 cache block。</span>
<span class="linenos">178</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">179</span><span class="w">  </span><span class="c1">// all_reserved 被初始化为 true，是指所有 cache line 都没有能够逐出来为新访</span>
<span class="linenos">180</span><span class="w">  </span><span class="c1">// 问提供 RESERVE 的空间，这里一旦满足上面两个 if 条件，说明当前 line 可以被</span>
<span class="linenos">181</span><span class="w">  </span><span class="c1">// 逐出来提供空间供 RESERVE 新访问，这里 all_reserved 置为 false。而一旦最终</span>
<span class="linenos">182</span><span class="w">  </span><span class="c1">// all_reserved 仍旧保持 true 的话，就说明当前 set 里没有哪一个 way 的 cache</span>
<span class="linenos">183</span><span class="w">  </span><span class="c1">// block 可以被逐出，发生 RESERVATION_FAIL。</span>
<span class="linenos">184</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">all_reserved</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">185</span><span class="w">    </span><span class="c1">// all of the blocks in the current set have no enough space in cache</span>
<span class="linenos">186</span><span class="w">    </span><span class="c1">// to allocate on miss.</span>
<span class="linenos">187</span><span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_alloc_policy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ON_MISS</span><span class="p">);</span>
<span class="linenos">188</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span><span class="w">  </span><span class="c1">// miss and not enough space in cache to</span>
<span class="linenos">189</span><span class="w">                              </span><span class="c1">// allocate on miss</span>
<span class="linenos">190</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">191</span>
<span class="linenos">192</span><span class="w">  </span><span class="c1">// 如果上面的 all_reserved 为 false，才会到这一步，即 cache line 可以被逐出</span>
<span class="linenos">193</span><span class="w">  </span><span class="c1">// 来为新访问提供 RESERVE。</span>
<span class="linenos">194</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">invalid_line</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">195</span><span class="w">    </span><span class="c1">// 尽管配置有 LRU 或者 FIFO 替换策略，但是最理想的情况还是优先替换整个 cache</span>
<span class="linenos">196</span><span class="w">    </span><span class="c1">// block 都无效的块。因为这种无效的块不需要写回，能够节省带宽。</span>
<span class="linenos">197</span><span class="w">    </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">invalid_line</span><span class="p">;</span>
<span class="linenos">198</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">valid_line</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">199</span><span class="w">    </span><span class="c1">// 没有无效的块，就只能将上面按照 LRU 或者 FIFO 确定的 cache block 作为被</span>
<span class="linenos">200</span><span class="w">    </span><span class="c1">// 逐出的块了。</span>
<span class="linenos">201</span><span class="w">    </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">valid_line</span><span class="p">;</span>
<span class="linenos">202</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span>
<span class="linenos">203</span><span class="w">    </span><span class="n">abort</span><span class="p">();</span><span class="w">  </span><span class="c1">// if an unreserved block exists, it is either invalid or</span>
<span class="linenos">204</span><span class="w">              </span><span class="c1">// replaceable</span>
<span class="linenos">205</span>
<span class="linenos">206</span><span class="w">  </span><span class="c1">// if (probe_mode &amp;&amp; m_config.is_streaming()) {</span>
<span class="linenos">207</span><span class="w">  </span><span class="c1">//   line_table::const_iterator i =</span>
<span class="linenos">208</span><span class="w">  </span><span class="c1">//       pending_lines.find(m_config.block_addr(addr));</span>
<span class="linenos">209</span><span class="w">  </span><span class="c1">//   assert(mf);</span>
<span class="linenos">210</span><span class="w">  </span><span class="c1">//   if (!mf-&gt;is_write() &amp;&amp; i != pending_lines.end()) {</span>
<span class="linenos">211</span><span class="w">  </span><span class="c1">//     if (i-&gt;second != mf-&gt;get_inst().get_uid()) return SECTOR_MISS;</span>
<span class="linenos">212</span><span class="w">  </span><span class="c1">//   }</span>
<span class="linenos">213</span><span class="w">  </span><span class="c1">// }</span>
<span class="linenos">214</span>
<span class="linenos">215</span><span class="w">  </span><span class="c1">// 如果上面的 cache line 可以被逐出来 reserve 新访问，则返回 MISS。</span>
<span class="linenos">216</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MISS</span><span class="p">;</span>
<span class="linenos">217</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-cache-process-tag-probe">
<div class="code-block-caption"><span class="caption-number">列表 1.10 </span><span class="caption-text">data_cache::process_tag_probe() 函数</span><a class="headerlink" href="#code-cache-process-tag-probe" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::process_tag_probe</span><span class="p">(</span>
<span class="linenos"> 1</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">wr</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">probe_status</span><span class="p">,</span><span class="w"> </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="linenos"> 2</span><span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 3</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="c1">// Each function pointer ( m_[rd/wr]_[hit/miss] ) is set in the</span>
<span class="linenos"> 5</span><span class="w">  </span><span class="c1">// data_cache constructor to reflect the corresponding cache configuration</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="c1">// options. Function pointers were used to avoid many long conditional</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="c1">// branches resulting from many cache configuration options.</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">access_status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">probe_status</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Write</span>
<span class="linenos">10</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">probe_status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">HIT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">      </span><span class="c1">//这里会在cache_index中写入cache block的索引。</span>
<span class="linenos">12</span><span class="w">      </span><span class="n">access_status</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">13</span><span class="w">          </span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;*</span><span class="n">m_wr_hit</span><span class="p">)(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">probe_status</span><span class="p">);</span>
<span class="linenos">14</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">probe_status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="linenos">15</span><span class="w">              </span><span class="p">(</span><span class="n">probe_status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos">16</span><span class="w">                </span><span class="n">m_config</span><span class="p">.</span><span class="n">m_write_alloc_policy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NO_WRITE_ALLOCATE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">17</span><span class="w">      </span><span class="n">access_status</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">18</span><span class="w">          </span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;*</span><span class="n">m_wr_miss</span><span class="p">)(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">probe_status</span><span class="p">);</span>
<span class="linenos">19</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">20</span><span class="w">      </span><span class="c1">// the only reason for reservation fail here is LINE_ALLOC_FAIL (i.e all</span>
<span class="linenos">21</span><span class="w">      </span><span class="c1">// lines are reserved)</span>
<span class="linenos">22</span><span class="w">      </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">LINE_ALLOC_FAIL</span><span class="p">);</span>
<span class="linenos">23</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">24</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Read</span>
<span class="linenos">25</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">probe_status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">HIT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">26</span><span class="w">      </span><span class="n">access_status</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">27</span><span class="w">          </span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;*</span><span class="n">m_rd_hit</span><span class="p">)(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">probe_status</span><span class="p">);</span>
<span class="linenos">28</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">probe_status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">29</span><span class="w">      </span><span class="n">access_status</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">30</span><span class="w">          </span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;*</span><span class="n">m_rd_miss</span><span class="p">)(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">probe_status</span><span class="p">);</span>
<span class="linenos">31</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">32</span><span class="w">      </span><span class="c1">// the only reason for reservation fail here is LINE_ALLOC_FAIL (i.e all</span>
<span class="linenos">33</span><span class="w">      </span><span class="c1">// lines are reserved)</span>
<span class="linenos">34</span><span class="w">      </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">LINE_ALLOC_FAIL</span><span class="p">);</span>
<span class="linenos">35</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">36</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="w">  </span><span class="n">m_bandwidth_management</span><span class="p">.</span><span class="n">use_data_port</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">access_status</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">39</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">access_status</span><span class="p">;</span>
<span class="linenos">40</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-tag-array-access">
<div class="code-block-caption"><span class="caption-number">列表 1.11 </span><span class="caption-text">tag_array::access() 函数</span><a class="headerlink" href="#code-tag-array-access" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">  0</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">tag_array::access</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos">  1</span><span class="w">                                            </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">&amp;</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wb</span><span class="p">,</span>
<span class="linenos">  2</span><span class="w">                                            </span><span class="n">evicted_block_info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">evicted</span><span class="p">,</span>
<span class="linenos">  3</span><span class="w">                                            </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">  4</span><span class="w">  </span><span class="c1">// 对当前 tag_array 的访问次数加 1。</span>
<span class="linenos">  5</span><span class="w">  </span><span class="n">m_access</span><span class="o">++</span><span class="p">;</span>
<span class="linenos">  6</span><span class="w">  </span><span class="c1">// 标记当前 tag_array 所属 cache 是否被使用过。一旦有 access() 函数被调用，则</span>
<span class="linenos">  7</span><span class="w">  </span><span class="c1">// 说明被使用过。</span>
<span class="linenos">  8</span><span class="w">  </span><span class="n">is_used</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos">  9</span><span class="w">  </span><span class="n">shader_cache_access_log</span><span class="p">(</span><span class="n">m_core_id</span><span class="p">,</span><span class="w"> </span><span class="n">m_type_id</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// log accesses to cache</span>
<span class="linenos"> 10</span><span class="w">  </span><span class="c1">// 由于当前函数没有把之前 probe 函数的 cache 访问状态传参进来，这里这个 probe</span>
<span class="linenos"> 11</span><span class="w">  </span><span class="c1">// 单纯的重新获取这个状态。</span>
<span class="linenos"> 12</span><span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">probe</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">is_write</span><span class="p">());</span>
<span class="linenos"> 13</span><span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 14</span><span class="w">    </span><span class="c1">// 新访问是 HIT_RESERVED 的话，不执行动作。</span>
<span class="linenos"> 15</span><span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">HIT_RESERVED</span><span class="p">:</span>
<span class="linenos"> 16</span><span class="w">      </span><span class="n">m_pending_hit</span><span class="o">++</span><span class="p">;</span>
<span class="linenos"> 17</span><span class="w">    </span><span class="c1">// 新访问是 HIT 的话，设置第 idx 号 cache line 以及 mask 对应的 sector 的最</span>
<span class="linenos"> 18</span><span class="w">    </span><span class="c1">// 末此访问时间为当前拍。</span>
<span class="linenos"> 19</span><span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">HIT</span><span class="p">:</span>
<span class="linenos"> 20</span><span class="w">      </span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">set_last_access_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos"> 21</span><span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="linenos"> 22</span><span class="w">    </span><span class="c1">// 新访问是 MISS 的话，说明已经选定 m_lines[idx] 作为逐出并 reserve 新访问的</span>
<span class="linenos"> 23</span><span class="w">    </span><span class="c1">// cache line。</span>
<span class="linenos"> 24</span><span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">MISS</span><span class="p">:</span>
<span class="linenos"> 25</span><span class="w">      </span><span class="n">m_miss</span><span class="o">++</span><span class="p">;</span>
<span class="linenos"> 26</span><span class="w">      </span><span class="n">shader_cache_access_log</span><span class="p">(</span><span class="n">m_core_id</span><span class="p">,</span><span class="w"> </span><span class="n">m_type_id</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// log cache misses</span>
<span class="linenos"> 27</span><span class="w">      </span><span class="c1">// For V100, L1 cache and L2 cache are all `allocate on miss`.</span>
<span class="linenos"> 28</span><span class="w">      </span><span class="c1">// m_alloc_policy，分配策略：</span>
<span class="linenos"> 29</span><span class="w">      </span><span class="c1">//     对于发送到 L1D cache 的请求：</span>
<span class="linenos"> 30</span><span class="w">      </span><span class="c1">//         如果命中，则立即返回所需数据；</span>
<span class="linenos"> 31</span><span class="w">      </span><span class="c1">//         如果未命中，则分配与缓存未命中相关的资源并将请求转至 L2 cache。</span>
<span class="linenos"> 32</span><span class="w">      </span><span class="c1">//     allocateon-miss/fill 是两种缓存行分配策略。对于 allocateon-miss，需</span>
<span class="linenos"> 33</span><span class="w">      </span><span class="c1">//     为未完成的未命中分配一个缓存行槽、一个 MSHR 和一个未命中队列条目。相比</span>
<span class="linenos"> 34</span><span class="w">      </span><span class="c1">//     之下，allocate-on-fill，当未完成的未命中发生时，需要分配一个 MSHR 和</span>
<span class="linenos"> 35</span><span class="w">      </span><span class="c1">//     一个未命中队列条目，但当所需数据从较低内存级别返回时，会选择受害者缓存</span>
<span class="linenos"> 36</span><span class="w">      </span><span class="c1">//     行槽。在这两种策略中，如果任何所需资源不可用，则会发生预留失败，内存管</span>
<span class="linenos"> 37</span><span class="w">      </span><span class="c1">//     道会停滞。分配的 MSHR 会被保留，直到从 L2 缓存/片外内存中获取数据，而</span>
<span class="linenos"> 38</span><span class="w">      </span><span class="c1">//     未命中队列条目会在未命中请求转发到 L2 缓存后被释放。由于 allocate-on-</span>
<span class="linenos"> 39</span><span class="w">      </span><span class="c1">//     fill 在驱逐之前将受害者缓存行保留在缓存中更长时间，并为未完成的未命中</span>
<span class="linenos"> 40</span><span class="w">      </span><span class="c1">//     保留更少的资源，因此它往往能获得更多的缓存命中和更少的预留失败，从而比</span>
<span class="linenos"> 41</span><span class="w">      </span><span class="c1">//     allocate-on-miss 具有更好的性能。尽管填充时分配需要额外的缓冲和流控制</span>
<span class="linenos"> 42</span><span class="w">      </span><span class="c1">//     逻辑来按顺序将数据填充到缓存中，但按顺序执行模型和写入驱逐策略使 GPU</span>
<span class="linenos"> 43</span><span class="w">      </span><span class="c1">//     L1D 缓存对填充时分配很友好，因为在填充时要驱逐受害者缓存时，没有脏数据</span>
<span class="linenos"> 44</span><span class="w">      </span><span class="c1">//     写入 L2。</span>
<span class="linenos"> 45</span><span class="w">      </span><span class="c1">//     详见 paper：</span>
<span class="linenos"> 46</span><span class="w">      </span><span class="c1">//     The Demand for a Sound Baseline in GPU Memory Architecture Research.</span>
<span class="linenos"> 47</span><span class="w">      </span><span class="c1">//     https://hzhou.wordpress.ncsu.edu/files/2022/12/Hongwen_WDDD2017.pdf</span>
<span class="linenos"> 48</span><span class="w">      </span><span class="c1">//</span>
<span class="linenos"> 49</span><span class="w">      </span><span class="c1">//     For streaming cache: (1) we set the alloc policy to be on-fill</span>
<span class="linenos"> 50</span><span class="w">      </span><span class="c1">//     to remove all line_alloc_fail stalls. if the whole memory is</span>
<span class="linenos"> 51</span><span class="w">      </span><span class="c1">//     allocated to the L1 cache, then make the allocation to be on</span>
<span class="linenos"> 52</span><span class="w">      </span><span class="c1">//     MISS, otherwise, make it ON_FILL to eliminate line allocation</span>
<span class="linenos"> 53</span><span class="w">      </span><span class="c1">//     fails. i.e. MSHR throughput is the same, independent on the L1</span>
<span class="linenos"> 54</span><span class="w">      </span><span class="c1">//     cache size/associativity So, we set the allocation policy per</span>
<span class="linenos"> 55</span><span class="w">      </span><span class="c1">//     kernel basis, see shader.cc, max_cta() function. (2) We also</span>
<span class="linenos"> 56</span><span class="w">      </span><span class="c1">//     set the MSHRs to be equal to max allocated cache lines. This</span>
<span class="linenos"> 57</span><span class="w">      </span><span class="c1">//     is possible by moving TAG to be shared between cache line and</span>
<span class="linenos"> 58</span><span class="w">      </span><span class="c1">//     MSHR enrty (i.e. for each cache line, there is an MSHR entry</span>
<span class="linenos"> 59</span><span class="w">      </span><span class="c1">//     associated with it). This is the easiest think we can think of</span>
<span class="linenos"> 60</span><span class="w">      </span><span class="c1">//     to model (mimic) L1 streaming cache in Pascal and Volta. For</span>
<span class="linenos"> 61</span><span class="w">      </span><span class="c1">//     more information about streaming cache, see:</span>
<span class="linenos"> 62</span><span class="w">      </span><span class="c1">//     https://www2.maths.ox.ac.uk/~gilesm/cuda/lecs/VoltaAG_Oxford.pdf</span>
<span class="linenos"> 63</span><span class="w">      </span><span class="c1">//     https://ieeexplore.ieee.org/document/8344474/</span>
<span class="linenos"> 64</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_alloc_policy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ON_MISS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 65</span><span class="w">        </span><span class="c1">// 访问时遇到 MISS，说明 probe 确定的 idx 号 cache line 需要被逐出来为新</span>
<span class="linenos"> 66</span><span class="w">        </span><span class="c1">// 访问提供 RESERVE 的空间。但是，这里需要判断 idx 号 cache line 是否是</span>
<span class="linenos"> 67</span><span class="w">        </span><span class="c1">// MODIFIED，如果是的话，需要执行写回，设置写回的标志为 wb = true，设置逐</span>
<span class="linenos"> 68</span><span class="w">        </span><span class="c1">// 出 cache line 的信息。</span>
<span class="linenos"> 69</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_modified_line</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 70</span><span class="w">          </span><span class="c1">// m_lines[idx] 作为逐出并 reserve 新访问的 cache line，如果它的某个</span>
<span class="linenos"> 71</span><span class="w">          </span><span class="c1">// sector 已经被 MODIFIED，则需要执行写回操作，设置写回标志为 wb = true，</span>
<span class="linenos"> 72</span><span class="w">          </span><span class="c1">// 设置逐出 cache line 的信息。</span>
<span class="linenos"> 73</span><span class="w">          </span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos"> 74</span><span class="w">          </span><span class="n">evicted</span><span class="p">.</span><span class="n">set_info</span><span class="p">(</span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">m_block_addr</span><span class="p">,</span>
<span class="linenos"> 75</span><span class="w">                          </span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">get_modified_size</span><span class="p">(),</span>
<span class="linenos"> 76</span><span class="w">                          </span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">get_dirty_byte_mask</span><span class="p">(),</span>
<span class="linenos"> 77</span><span class="w">                          </span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">get_dirty_sector_mask</span><span class="p">());</span>
<span class="linenos"> 78</span><span class="w">          </span><span class="c1">// 由于执行写回操作，MODIFIED 造成的 m_dirty 数量应该减1。</span>
<span class="linenos"> 79</span><span class="w">          </span><span class="n">m_dirty</span><span class="o">--</span><span class="p">;</span>
<span class="linenos"> 80</span><span class="w">        </span><span class="p">}</span>
<span class="linenos"> 81</span><span class="w">        </span><span class="c1">// 执行对新访问的 reserve 操作。</span>
<span class="linenos"> 82</span><span class="w">        </span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">tag</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
<span class="linenos"> 83</span><span class="w">                              </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos"> 84</span><span class="w">      </span><span class="p">}</span>
<span class="linenos"> 85</span><span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="linenos"> 86</span><span class="w">    </span><span class="c1">// Cache block 有效，但是其中的 byte mask = Cache block[mask] 状态无效，说明</span>
<span class="linenos"> 87</span><span class="w">    </span><span class="c1">// sector 缺失。</span>
<span class="linenos"> 88</span><span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SECTOR_MISS</span><span class="p">:</span>
<span class="linenos"> 89</span><span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_cache_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SECTOR</span><span class="p">);</span>
<span class="linenos"> 90</span><span class="w">      </span><span class="n">m_sector_miss</span><span class="o">++</span><span class="p">;</span>
<span class="linenos"> 91</span><span class="w">      </span><span class="n">shader_cache_access_log</span><span class="p">(</span><span class="n">m_core_id</span><span class="p">,</span><span class="w"> </span><span class="n">m_type_id</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// log cache misses</span>
<span class="linenos"> 92</span><span class="w">      </span><span class="c1">// For V100, L1 cache and L2 cache are all `allocate on miss`.</span>
<span class="linenos"> 93</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_alloc_policy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ON_MISS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 94</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_modified_line</span><span class="p">();</span>
<span class="linenos"> 95</span><span class="w">        </span><span class="c1">// 设置 m_lines[idx] 为新访问分配一个 sector。</span>
<span class="linenos"> 96</span><span class="w">        </span><span class="p">((</span><span class="n">sector_cache_block</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
<span class="linenos"> 97</span><span class="w">            </span><span class="o">-&gt;</span><span class="n">allocate_sector</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos"> 98</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">before</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">m_lines</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_modified_line</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 99</span><span class="w">          </span><span class="n">m_dirty</span><span class="o">--</span><span class="p">;</span>
<span class="linenos">100</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">101</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">102</span><span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="linenos">103</span><span class="w">    </span><span class="c1">// probe函数中：</span>
<span class="linenos">104</span><span class="w">    </span><span class="c1">// all_reserved 被初始化为 true，是指所有 cache line 都没有能够逐出来为新访问</span>
<span class="linenos">105</span><span class="w">    </span><span class="c1">// 提供 RESERVE 的空间，这里一旦满足函数两个 if 条件，说明 cache line 可以被逐</span>
<span class="linenos">106</span><span class="w">    </span><span class="c1">// 出来提供空间供 RESERVE 新访问，这里 all_reserved 置为 false。</span>
<span class="linenos">107</span><span class="w">    </span><span class="c1">// 而一旦最终 all_reserved 仍旧保持 true 的话，就说明 cache line 不可被逐出，</span>
<span class="linenos">108</span><span class="w">    </span><span class="c1">// 发生 RESERVATION_FAIL。因此这里不执行任何操作。</span>
<span class="linenos">109</span><span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">RESERVATION_FAIL</span><span class="p">:</span>
<span class="linenos">110</span><span class="w">      </span><span class="n">m_res_fail</span><span class="o">++</span><span class="p">;</span>
<span class="linenos">111</span><span class="w">      </span><span class="n">shader_cache_access_log</span><span class="p">(</span><span class="n">m_core_id</span><span class="p">,</span><span class="w"> </span><span class="n">m_type_id</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// log cache misses</span>
<span class="linenos">112</span><span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="linenos">113</span><span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="linenos">114</span><span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
<span class="linenos">115</span><span class="w">              </span><span class="s">&quot;tag_array::access - Error: Unknown&quot;</span>
<span class="linenos">116</span><span class="w">              </span><span class="s">&quot;cache_request_status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="linenos">117</span><span class="w">              </span><span class="n">status</span><span class="p">);</span>
<span class="linenos">118</span><span class="w">      </span><span class="n">abort</span><span class="p">();</span>
<span class="linenos">119</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">120</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="linenos">121</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-rd-miss-base">
<div class="code-block-caption"><span class="caption-number">列表 1.12 </span><span class="caption-text">data_cache::rd_miss_base() 函数</span><a class="headerlink" href="#code-data-cache-rd-miss-base" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="cm">/****** Read miss functions (Set by config file) ******/</span>
<span class="linenos"> 1</span>
<span class="linenos"> 2</span><span class="c1">// Baseline read miss: Send read request to lower level memory,</span>
<span class="linenos"> 3</span><span class="c1">// perform write-back as necessary</span>
<span class="linenos"> 4</span><span class="cm">/*</span>
<span class="linenos"> 5</span><span class="cm">READ MISS 操作。</span>
<span class="linenos"> 6</span><span class="cm">*/</span>
<span class="linenos"> 7</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::rd_miss_base</span><span class="p">(</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">10</span><span class="w">  </span><span class="c1">// 读 miss 时，就需要将数据请求发送至下一级存储。这里或许需要真实地向下一级存储发</span>
<span class="linenos">11</span><span class="w">  </span><span class="c1">// 送读请求，也或许由于 mshr 的存在，可以将数据请求合并进去，这样就不需要真实地向</span>
<span class="linenos">12</span><span class="w">  </span><span class="c1">// 下一级存储发送读请求。</span>
<span class="linenos">13</span><span class="w">  </span><span class="c1">// miss_queue_full 检查是否一个 miss 请求能够在当前时钟周期内被处理，当一个请求</span>
<span class="linenos">14</span><span class="w">  </span><span class="c1">// 的大小大到 m_miss_queue 放不下时即在当前拍内无法处理，发生 RESERVATION_FAIL。</span>
<span class="linenos">15</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">    </span><span class="c1">// cannot handle request this cycle (might need to generate two requests).</span>
<span class="linenos">17</span><span class="w">    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MISS_QUEUE_FULL</span><span class="p">);</span>
<span class="linenos">18</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">19</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="w">  </span><span class="c1">// m_config.block_addr(addr):</span>
<span class="linenos">22</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_line_sz - 1);</span>
<span class="linenos">23</span><span class="w">  </span><span class="c1">// |-------|-------------|--------------|</span>
<span class="linenos">24</span><span class="w">  </span><span class="c1">//            set_index   offset in-line</span>
<span class="linenos">25</span><span class="w">  </span><span class="c1">// |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 |</span>
<span class="linenos">26</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos">27</span><span class="w">  </span><span class="c1">// 标识是否请求被填充进 MSHR 或者 被放到 m_miss_queue 以在下一个周期发送到下一</span>
<span class="linenos">28</span><span class="w">  </span><span class="c1">// 级存储。</span>
<span class="linenos">29</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_miss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos">30</span><span class="w">  </span><span class="c1">// wb 代表是否需要写回（当一个被逐出的 cache block 被 MODIFIED 时，需要写回到</span>
<span class="linenos">31</span><span class="w">  </span><span class="c1">// 下一级存储），evicted代表被逐出的 cache line 的信息。</span>
<span class="linenos">32</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos">33</span><span class="w">  </span><span class="n">evicted_block_info</span><span class="w"> </span><span class="n">evicted</span><span class="p">;</span>
<span class="linenos">34</span><span class="w">  </span><span class="c1">// READ MISS 处理函数，检查 MSHR 是否命中或者 MSHR 是否可用，依此判断是否需要</span>
<span class="linenos">35</span><span class="w">  </span><span class="c1">// 向下一级存储发送读请求。</span>
<span class="linenos">36</span><span class="w">  </span><span class="n">send_read_request</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">do_miss</span><span class="p">,</span><span class="w"> </span><span class="n">wb</span><span class="p">,</span>
<span class="linenos">37</span><span class="w">                    </span><span class="n">evicted</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="linenos">38</span><span class="w">  </span><span class="c1">// 如果 send_read_request 中数据请求已经被加入到 MSHR，或是原先存在该条目将请</span>
<span class="linenos">39</span><span class="w">  </span><span class="c1">// 求合并进去，或是原先不存在该条目将请求插入进去，那么 do_miss 为 true，代表</span>
<span class="linenos">40</span><span class="w">  </span><span class="c1">// 要将某个cache block逐出并接收 mf 从下一级存储返回的数据。</span>
<span class="linenos">41</span><span class="w">  </span><span class="c1">// m_lines[idx] 作为逐出并 reserve 新访问的 cache line，如果它的某个 sector</span>
<span class="linenos">42</span><span class="w">  </span><span class="c1">// 已经被MODIFIED，则需要执行写回操作，设置写回的标志为 wb = true。</span>
<span class="linenos">43</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">do_miss</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">44</span><span class="w">    </span><span class="c1">// If evicted block is modified and not a write-through</span>
<span class="linenos">45</span><span class="w">    </span><span class="c1">// (already modified lower level).</span>
<span class="linenos">46</span><span class="w">    </span><span class="c1">// 这里如果 cache 的写策略为写直达，就不需要在读 miss 时将被逐出的 MODIFIED</span>
<span class="linenos">47</span><span class="w">    </span><span class="c1">// cache block 写回到下一级存储，因为这个 cache block 在被 MODIFIED 的时候</span>
<span class="linenos">48</span><span class="w">    </span><span class="c1">// 已经被 write-through 到下一级存储了。</span>
<span class="linenos">49</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wb</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_write_policy</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WRITE_THROUGH</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">50</span><span class="w">      </span><span class="c1">// 发送写请求，将 MODIFIED 的被逐出的 cache block 写回到下一级存储。</span>
<span class="linenos">51</span><span class="w">      </span><span class="c1">// 在 V100 中，</span>
<span class="linenos">52</span><span class="w">      </span><span class="c1">//     m_wrbk_type：L1 cache 为 L1_WRBK_ACC，L2 cache 为 L2_WRBK_ACC。</span>
<span class="linenos">53</span><span class="w">      </span><span class="c1">//     m_write_policy：L1 cache 为 WRITE_THROUGH。</span>
<span class="linenos">54</span><span class="w">      </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_memfetch_creator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span>
<span class="linenos">55</span><span class="w">          </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">m_wrbk_type</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_warp_mask</span><span class="p">(),</span>
<span class="linenos">56</span><span class="w">          </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_byte_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_sector_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_modified_size</span><span class="p">,</span>
<span class="linenos">57</span><span class="w">          </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_tot_sim_cycle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_sim_cycle</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span>
<span class="linenos">58</span><span class="w">          </span><span class="nb">NULL</span><span class="p">);</span>
<span class="linenos">59</span><span class="w">      </span><span class="c1">// the evicted block may have wrong chip id when advanced L2 hashing</span>
<span class="linenos">60</span><span class="w">      </span><span class="c1">// is used, so set the right chip address from the original mf.</span>
<span class="linenos">61</span><span class="w">      </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_chip</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">chip</span><span class="p">);</span>
<span class="linenos">62</span><span class="w">      </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_partition</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">sub_partition</span><span class="p">);</span>
<span class="linenos">63</span><span class="w">      </span><span class="c1">// 将数据写请求一同发送至下一级存储。</span>
<span class="linenos">64</span><span class="w">      </span><span class="c1">// 需要做的是将读请求类型 WRITE_BACK_REQUEST_SENT放 入events，并将数据请</span>
<span class="linenos">65</span><span class="w">      </span><span class="c1">// 求 mf 放入当前 cache 的 m_miss_queue 中，等 baseline_cache::cycle()</span>
<span class="linenos">66</span><span class="w">      </span><span class="c1">// 将队首的数据请求 mf 发送给下一级存储。</span>
<span class="linenos">67</span><span class="w">      </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">WRITE_BACK_REQUEST_SENT</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">68</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">69</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MISS</span><span class="p">;</span>
<span class="linenos">70</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">71</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">72</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-baseline-cache-send-read-request">
<div class="code-block-caption"><span class="caption-number">列表 1.13 </span><span class="caption-text">baseline_cache::send_read_request() 函数</span><a class="headerlink" href="#code-baseline-cache-send-read-request" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">  0</span><span class="c1">// Read miss handler. Check MSHR hit or MSHR available</span>
<span class="linenos">  1</span><span class="cm">/*</span>
<span class="linenos">  2</span><span class="cm">READ MISS 处理函数，检查 MSHR 是否命中或者 MSHR 是否可用，依此判断是否需要向下一</span>
<span class="linenos">  3</span><span class="cm">级存储发送读请求。</span>
<span class="linenos">  4</span><span class="cm">*/</span>
<span class="linenos">  5</span><span class="kt">void</span><span class="w"> </span><span class="nf">baseline_cache::send_read_request</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="linenos">  6</span><span class="w">                                       </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="p">,</span>
<span class="linenos">  7</span><span class="w">                                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span>
<span class="linenos">  8</span><span class="w">                                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">&amp;</span><span class="n">do_miss</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wb</span><span class="p">,</span>
<span class="linenos">  9</span><span class="w">                                       </span><span class="n">evicted_block_info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">evicted</span><span class="p">,</span>
<span class="linenos"> 10</span><span class="w">                                       </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span>
<span class="linenos"> 11</span><span class="w">                                       </span><span class="kt">bool</span><span class="w"> </span><span class="n">read_only</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">wa</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 12</span><span class="w">  </span><span class="c1">// 1. 如果是 Sector Cache：</span>
<span class="linenos"> 13</span><span class="w">  </span><span class="c1">//  mshr_addr 函数返回 mshr 的地址，该地址即为地址 addr 的 tag 位 + set index</span>
<span class="linenos"> 14</span><span class="w">  </span><span class="c1">//  位 + sector offset 位。即除 single sector byte offset 位 以外的所有位。</span>
<span class="linenos"> 15</span><span class="w">  </span><span class="c1">//  |&lt;----------mshr_addr-----------&gt;|</span>
<span class="linenos"> 16</span><span class="w">  </span><span class="c1">//                     sector offset  off in-sector</span>
<span class="linenos"> 17</span><span class="w">  </span><span class="c1">//                     |-------------|-----------|</span>
<span class="linenos"> 18</span><span class="w">  </span><span class="c1">//                      \                       /</span>
<span class="linenos"> 19</span><span class="w">  </span><span class="c1">//                       \                     /</span>
<span class="linenos"> 20</span><span class="w">  </span><span class="c1">//  |-------|-------------|-------------------|</span>
<span class="linenos"> 21</span><span class="w">  </span><span class="c1">//             set_index     offset in-line</span>
<span class="linenos"> 22</span><span class="w">  </span><span class="c1">//  |&lt;----tag----&gt; 0 0 0 0|</span>
<span class="linenos"> 23</span><span class="w">  </span><span class="c1">// 2. 如果是 Line Cache：</span>
<span class="linenos"> 24</span><span class="w">  </span><span class="c1">//  mshr_addr 函数返回 mshr 的地址，该地址即为地址 addr 的 tag 位 + set index</span>
<span class="linenos"> 25</span><span class="w">  </span><span class="c1">//  位。即除 single line byte off-set 位 以外的所有位。</span>
<span class="linenos"> 26</span><span class="w">  </span><span class="c1">//  |&lt;----mshr_addr---&gt;|</span>
<span class="linenos"> 27</span><span class="w">  </span><span class="c1">//                              line offset</span>
<span class="linenos"> 28</span><span class="w">  </span><span class="c1">//                     |-------------------------|</span>
<span class="linenos"> 29</span><span class="w">  </span><span class="c1">//                      \                       /</span>
<span class="linenos"> 30</span><span class="w">  </span><span class="c1">//                       \                     /</span>
<span class="linenos"> 31</span><span class="w">  </span><span class="c1">//  |-------|-------------|-------------------|</span>
<span class="linenos"> 32</span><span class="w">  </span><span class="c1">//             set_index     offset in-line</span>
<span class="linenos"> 33</span><span class="w">  </span><span class="c1">//  |&lt;----tag----&gt; 0 0 0 0|</span>
<span class="linenos"> 34</span><span class="w">  </span><span class="c1">//</span>
<span class="linenos"> 35</span><span class="w">  </span><span class="c1">// mshr_addr 定义：</span>
<span class="linenos"> 36</span><span class="w">  </span><span class="c1">//   new_addr_type mshr_addr(new_addr_type addr) const {</span>
<span class="linenos"> 37</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_atom_sz - 1);</span>
<span class="linenos"> 38</span><span class="w">  </span><span class="c1">//   }</span>
<span class="linenos"> 39</span><span class="w">  </span><span class="c1">// m_atom_sz = (m_cache_type == SECTOR) ? SECTOR_SIZE : m_line_sz;</span>
<span class="linenos"> 40</span><span class="w">  </span><span class="c1">// 其中 SECTOR_SIZE = const (32 bytes per sector).</span>
<span class="linenos"> 41</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">mshr_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">mshr_addr</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_addr</span><span class="p">());</span>
<span class="linenos"> 42</span><span class="w">  </span><span class="c1">// 这里实际上是 MSHR 查找是否已经有 mshr_addr 的请求被合并到 MSHR。如果已经被挂</span>
<span class="linenos"> 43</span><span class="w">  </span><span class="c1">// 起则 mshr_hit = true。需要注意，MSHR 中的条目是以 mshr_addr 为索引的，即来自</span>
<span class="linenos"> 44</span><span class="w">  </span><span class="c1">// 同一个 line（对于非 Sector Cache）或者来自同一个 sector（对于 Sector Cache）</span>
<span class="linenos"> 45</span><span class="w">  </span><span class="c1">// 的事务被合并，因为这种 cache 所请求的最小单位分别是一个 line 或者一个 sector，</span>
<span class="linenos"> 46</span><span class="w">  </span><span class="c1">// 因此没必要发送那么多事务，只需要发送一次即可。</span>
<span class="linenos"> 47</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">probe</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">);</span>
<span class="linenos"> 48</span><span class="w">  </span><span class="c1">// 如果 mshr_addr 在 MSHR 中已存在条目，m_mshrs.full 检查是否该条目的合并数量已</span>
<span class="linenos"> 49</span><span class="w">  </span><span class="c1">// 达到最大合并数；如果 mshr_addr 在 MSHR 中不存在条目，则检查是否有空闲的 MSHR</span>
<span class="linenos"> 50</span><span class="w">  </span><span class="c1">// 条目可以将 mshr_addr 插入进 MSHR。</span>
<span class="linenos"> 51</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">mshr_avail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">full</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">);</span>
<span class="linenos"> 52</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mshr_avail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 53</span><span class="w">    </span><span class="c1">// 如果 MSHR 命中，且 mshr_addr 对应条目的合并数量没有达到最大合并数，则将数据</span>
<span class="linenos"> 54</span><span class="w">    </span><span class="c1">// 请求 mf 加入到 MSHR 中。</span>
<span class="linenos"> 55</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">read_only</span><span class="p">)</span>
<span class="linenos"> 56</span><span class="w">      </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 57</span><span class="w">    </span><span class="k">else</span>
<span class="linenos"> 58</span><span class="w">      </span><span class="c1">// 更新 tag_array 的状态，包括更新 LRU 状态，设置逐出的 block 或 sector 等。</span>
<span class="linenos"> 59</span><span class="w">      </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 60</span>
<span class="linenos"> 61</span><span class="w">    </span><span class="c1">// 将 mshr_addr 地址的数据请求 mf 加入到 MSHR 中。因为命中 MSHR，说明前面已经</span>
<span class="linenos"> 62</span><span class="w">    </span><span class="c1">// 有对该数据的请求发送到下一级缓存了，因此这里只需要等待前面的请求返回即可。</span>
<span class="linenos"> 63</span><span class="w">    </span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 64</span><span class="w">    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MSHR_HIT</span><span class="p">);</span>
<span class="linenos"> 65</span><span class="w">    </span><span class="c1">// 标识是否请求被填充进 MSHR 或者 被放到 m_miss_queue 以在下一个周期发送到下一</span>
<span class="linenos"> 66</span><span class="w">    </span><span class="c1">// 级存储。</span>
<span class="linenos"> 67</span><span class="w">    </span><span class="n">do_miss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos"> 68</span>
<span class="linenos"> 69</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mshr_avail</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos"> 70</span><span class="w">            </span><span class="p">(</span><span class="n">m_miss_queue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">m_miss_queue_size</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 71</span><span class="w">    </span><span class="c1">// 如果 MSHR 未命中，但有空闲的 MSHR 条目可以将 mshr_addr 插入进 MSHR，则将数</span>
<span class="linenos"> 72</span><span class="w">    </span><span class="c1">// 据请求 mf 插入到 MSHR 中。</span>
<span class="linenos"> 73</span><span class="w">    </span><span class="c1">// 对于 L1 cache 和 L2 cache，read_only 为 false，对于 read_only_cache 来说，</span>
<span class="linenos"> 74</span><span class="w">    </span><span class="c1">// read_only 为true。</span>
<span class="linenos"> 75</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">read_only</span><span class="p">)</span>
<span class="linenos"> 76</span><span class="w">      </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 77</span><span class="w">    </span><span class="k">else</span>
<span class="linenos"> 78</span><span class="w">      </span><span class="c1">// 更新 tag_array 的状态，包括更新 LRU 状态，设置逐出的 block 或 sector 等。</span>
<span class="linenos"> 79</span><span class="w">      </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 80</span>
<span class="linenos"> 81</span><span class="w">    </span><span class="c1">// 将 mshr_addr 地址的数据请求 mf 加入到 MSHR 中。因为没有命中 MSHR，因此还需</span>
<span class="linenos"> 82</span><span class="w">    </span><span class="c1">// 要将该数据的请求发送到下一级缓存。</span>
<span class="linenos"> 83</span><span class="w">    </span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 84</span><span class="w">    </span><span class="c1">// if (m_config.is_streaming() &amp;&amp; m_config.m_cache_type == SECTOR) {</span>
<span class="linenos"> 85</span><span class="w">    </span><span class="c1">//   m_tag_array-&gt;add_pending_line(mf);</span>
<span class="linenos"> 86</span><span class="w">    </span><span class="c1">// }</span>
<span class="linenos"> 87</span><span class="w">    </span><span class="c1">// 设置 m_extra_mf_fields[mf]，意味着如果 mf 在 m_extra_mf_fields 中存在，即</span>
<span class="linenos"> 88</span><span class="w">    </span><span class="c1">// mf 等待着下一级存储的数据回到当前缓存填充。</span>
<span class="linenos"> 89</span><span class="w">    </span><span class="n">m_extra_mf_fields</span><span class="p">[</span><span class="n">mf</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extra_mf_fields</span><span class="p">(</span>
<span class="linenos"> 90</span><span class="w">        </span><span class="n">mshr_addr</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_addr</span><span class="p">(),</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_data_size</span><span class="p">(),</span><span class="w"> </span><span class="n">m_config</span><span class="p">);</span>
<span class="linenos"> 91</span><span class="w">    </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">set_data_size</span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">get_atom_sz</span><span class="p">());</span>
<span class="linenos"> 92</span><span class="w">    </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">set_addr</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">);</span>
<span class="linenos"> 93</span><span class="w">    </span><span class="c1">// mf 为 miss 的请求，加入 miss_queue，MISS 请求队列。</span>
<span class="linenos"> 94</span><span class="w">    </span><span class="c1">// 在 baseline_cache::cycle() 中，会将 m_miss_queue 队首的数据包 mf 传递给下</span>
<span class="linenos"> 95</span><span class="w">    </span><span class="c1">// 一层存储。因为没有命中 MSHR，说明前面没有对该数据的请求发送到下一级缓存，</span>
<span class="linenos"> 96</span><span class="w">    </span><span class="c1">// 因此这里需要把该请求发送给下一级存储。</span>
<span class="linenos"> 97</span><span class="w">    </span><span class="n">m_miss_queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 98</span><span class="w">    </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">set_status</span><span class="p">(</span><span class="n">m_miss_queue_status</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">);</span>
<span class="linenos"> 99</span><span class="w">    </span><span class="c1">// 在 V100 配置中，wa 对 L1/L2/read_only cache 均为 false。</span>
<span class="linenos">100</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">wa</span><span class="p">)</span><span class="w"> </span><span class="n">events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cache_event</span><span class="p">(</span><span class="n">READ_REQUEST_SENT</span><span class="p">));</span>
<span class="linenos">101</span><span class="w">    </span><span class="c1">// 标识是否请求被填充进 MSHR 或者 被放到 m_miss_queue 以在下一个周期发送到下一</span>
<span class="linenos">102</span><span class="w">    </span><span class="c1">// 级存储。</span>
<span class="linenos">103</span><span class="w">    </span><span class="n">do_miss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos">104</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">mshr_avail</span><span class="p">)</span>
<span class="linenos">105</span><span class="w">    </span><span class="c1">// 如果 MSHR 命中，但 mshr_addr 对应条目的合并数量达到了最大合并数。</span>
<span class="linenos">106</span><span class="w">    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MSHR_MERGE_ENRTY_FAIL</span><span class="p">);</span>
<span class="linenos">107</span><span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">mshr_avail</span><span class="p">)</span>
<span class="linenos">108</span><span class="w">    </span><span class="c1">// 如果 MSHR 未命中，且 mshr_addr 没有空闲的 MSHR 条目可将 mshr_addr 插入。</span>
<span class="linenos">109</span><span class="w">    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MSHR_ENRTY_FAIL</span><span class="p">);</span>
<span class="linenos">110</span><span class="w">  </span><span class="k">else</span>
<span class="linenos">111</span><span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="linenos">112</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-send-write-request">
<div class="code-block-caption"><span class="caption-number">列表 1.14 </span><span class="caption-text">data_cache::send_write_request() 函数</span><a class="headerlink" href="#code-data-cache-send-write-request" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="c1">// Sends write request to lower level memory (write or writeback)</span>
<span class="linenos"> 1</span><span class="cm">/*</span>
<span class="linenos"> 2</span><span class="cm">将数据写请求一同发送至下一级存储。这里需要做的是将写请求类型 WRITE_REQUEST_SENT 或</span>
<span class="linenos"> 3</span><span class="cm">WRITE_BACK_REQUEST_SENT 放入 events，并将数据请求 mf 放入 m_miss_queue中，等待下</span>
<span class="linenos"> 4</span><span class="cm">一时钟周期 baseline_cache::cycle() 将队首的数据请求 mf 发送给下一级存储。</span>
<span class="linenos"> 5</span><span class="cm">*/</span>
<span class="linenos"> 6</span><span class="kt">void</span><span class="w"> </span><span class="nf">data_cache::send_write_request</span><span class="p">(</span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="w"> </span><span class="n">request</span><span class="p">,</span>
<span class="linenos"> 7</span><span class="w">                                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">                                    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="n">events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
<span class="linenos">10</span><span class="w">  </span><span class="c1">// 在 baseline_cache::cycle() 中，会将 m_miss_queue 队首的数据包 mf 传递给下</span>
<span class="linenos">11</span><span class="w">  </span><span class="c1">// 一级存储。</span>
<span class="linenos">12</span><span class="w">  </span><span class="n">m_miss_queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="linenos">13</span><span class="w">  </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">set_status</span><span class="p">(</span><span class="n">m_miss_queue_status</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">);</span>
<span class="linenos">14</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-wr-hit-wb">
<div class="code-block-caption"><span class="caption-number">列表 1.15 </span><span class="caption-text">data_cache::wr_hit_wb() 函数</span><a class="headerlink" href="#code-data-cache-wr-hit-wb" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="cm">/****** Write-hit functions (Set by config file) ******/</span>
<span class="linenos"> 1</span>
<span class="linenos"> 2</span><span class="c1">// Write-back hit: Mark block as modified</span>
<span class="linenos"> 3</span><span class="cm">/*</span>
<span class="linenos"> 4</span><span class="cm">若 Write Hit 时采取 write-back 策略，则需要将数据单写入 cache，不需要直接将数据写入</span>
<span class="linenos"> 5</span><span class="cm">下一级存储。等到新数据 fill 进来时，再将旧数据逐出并写入下一级存储。</span>
<span class="linenos"> 6</span><span class="cm">*/</span>
<span class="linenos"> 7</span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::wr_hit_wb</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">                                           </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span>
<span class="linenos"> 9</span><span class="w">                                           </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos">10</span><span class="w">                                           </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span>
<span class="linenos">11</span><span class="w">                                           </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">12</span><span class="w">  </span><span class="c1">// m_config.block_addr(addr):</span>
<span class="linenos">13</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_line_sz - 1);</span>
<span class="linenos">14</span><span class="w">  </span><span class="c1">// |-------|-------------|--------------|</span>
<span class="linenos">15</span><span class="w">  </span><span class="c1">//            set_index   offset in-line</span>
<span class="linenos">16</span><span class="w">  </span><span class="c1">// |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 |</span>
<span class="linenos">17</span><span class="w">  </span><span class="c1">// write-back 策略不需要直接将数据写入下一级存储，因此不需要调用miss_queue_full()</span>
<span class="linenos">18</span><span class="w">  </span><span class="c1">// 以及 send_write_request() 函数来发送写回请求到下一级存储。</span>
<span class="linenos">19</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos">20</span><span class="w">  </span><span class="c1">// 更新 tag_array 的状态，包括更新 LRU 状态，设置逐出的 block 或 sector 等。</span>
<span class="linenos">21</span><span class="w">  </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos">22</span><span class="w">  </span><span class="n">cache_block_t</span><span class="w"> </span><span class="o">*</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">get_block</span><span class="p">(</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos">23</span><span class="w">  </span><span class="c1">// 如果 block 不是 modified line，则增加 dirty 计数。因为如果这个时候 block 不是</span>
<span class="linenos">24</span><span class="w">  </span><span class="c1">// modified line，说明这个 block 是 clean line，而现在要写入数据，因此需要将这个</span>
<span class="linenos">25</span><span class="w">  </span><span class="c1">// block 设置为 modified line。这样的话，dirty 计数就需要增加。但如果 block 已经</span>
<span class="linenos">26</span><span class="w">  </span><span class="c1">// 是 modified line，则不需要增加 dirty 计数，因为这个 block 在上次变成 dirty 的</span>
<span class="linenos">27</span><span class="w">  </span><span class="c1">// 时候，dirty 计数已经增加过了。</span>
<span class="linenos">28</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_modified_line</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">29</span><span class="w">    </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">inc_dirty</span><span class="p">();</span>
<span class="linenos">30</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">31</span><span class="w">  </span><span class="c1">// 设置 block 的状态为 modified，即将 block 设置为 MODIFIED。这样的话，下次再有</span>
<span class="linenos">32</span><span class="w">  </span><span class="c1">// 数据请求访问这个 block 的时候，就可以直接从 cache 中读取数据，而不需要再次访问</span>
<span class="linenos">33</span><span class="w">  </span><span class="c1">// 下一级存储。当然，当有下次填充进这个 block 的数据请求时（block 的 tag 与请求的</span>
<span class="linenos">34</span><span class="w">  </span><span class="c1">// tag 不一致），由于这个 block 的状态已经被设置为 modified，因此需要将此 block</span>
<span class="linenos">35</span><span class="w">  </span><span class="c1">// 的数据逐出并写回到下一级存储。</span>
<span class="linenos">36</span><span class="w">  </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_status</span><span class="p">(</span><span class="n">MODIFIED</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">37</span><span class="w">  </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_byte_mask</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="linenos">38</span><span class="w">  </span><span class="c1">// 更新一个 cache block 的状态为可读。但需要注意的是，这里的可读是指该 sector 可</span>
<span class="linenos">39</span><span class="w">  </span><span class="c1">// 读，而不是整个 block 可读。如果一个 sector 内的所有的 byte mask 位全都设置为</span>
<span class="linenos">40</span><span class="w">  </span><span class="c1">// dirty 了，则将该sector 可设置为可读，因为当前的 sector 已经是全部更新为最新值</span>
<span class="linenos">41</span><span class="w">  </span><span class="c1">// 了，是可读的。这个函数对所有的数据请求 mf 的所有访问的 sector 进行遍历，这里的</span>
<span class="linenos">42</span><span class="w">  </span><span class="c1">// sector 是由 mf 访问的，并由 mf-&gt;get_access_sector_mask() 确定。</span>
<span class="linenos">43</span><span class="w">  </span><span class="n">update_m_readable</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">HIT</span><span class="p">;</span>
<span class="linenos">46</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-wr-hit-wt">
<div class="code-block-caption"><span class="caption-number">列表 1.16 </span><span class="caption-text">data_cache::wr_hit_wt() 函数</span><a class="headerlink" href="#code-data-cache-wr-hit-wt" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="c1">// Write-through hit: Directly send request to lower level memory</span>
<span class="linenos"> 1</span><span class="cm">/*</span>
<span class="linenos"> 2</span><span class="cm">若 Write Hit 时采取 write-through 策略的话，则需要将数据不单单写入 cache，还需要直</span>
<span class="linenos"> 3</span><span class="cm">接将数据写入下一级存储。</span>
<span class="linenos"> 4</span><span class="cm">*/</span>
<span class="linenos"> 5</span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::wr_hit_wt</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="linenos"> 6</span><span class="w">                                           </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span>
<span class="linenos"> 7</span><span class="w">                                           </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">                                           </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span>
<span class="linenos"> 9</span><span class="w">                                           </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">10</span><span class="w">  </span><span class="c1">// miss_queue_full 检查是否一个 miss 请求能够在当前时钟周期内被处理，当一个请求的</span>
<span class="linenos">11</span><span class="w">  </span><span class="c1">// 大小大到 m_miss_queue 放不下时即在当前拍内无法处理，发生 RESERVATION_FAIL。</span>
<span class="linenos">12</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">13</span><span class="w">    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MISS_QUEUE_FULL</span><span class="p">);</span>
<span class="linenos">14</span><span class="w">    </span><span class="c1">// 如果 miss_queue 满了，但由于 write-through 策略要求数据应该直接写入下一级存</span>
<span class="linenos">15</span><span class="w">    </span><span class="c1">// 储，因此这里返回 RESERVATION_FAIL，表示当前时钟周期内无法处理该请求。</span>
<span class="linenos">16</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span><span class="w">  </span><span class="c1">// cannot handle request this cycle</span>
<span class="linenos">17</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">18</span><span class="w">  </span><span class="c1">// m_config.block_addr(addr):</span>
<span class="linenos">19</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_line_sz - 1);</span>
<span class="linenos">20</span><span class="w">  </span><span class="c1">// |-------|-------------|--------------|</span>
<span class="linenos">21</span><span class="w">  </span><span class="c1">//            set_index   offset in-line</span>
<span class="linenos">22</span><span class="w">  </span><span class="c1">// |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 |</span>
<span class="linenos">23</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos">24</span><span class="w">  </span><span class="c1">// 更新 tag_array 的状态，包括更新 LRU 状态，设置逐出的 block 或 sector 等。</span>
<span class="linenos">25</span><span class="w">  </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos">26</span><span class="w">  </span><span class="n">cache_block_t</span><span class="w"> </span><span class="o">*</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">get_block</span><span class="p">(</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos">27</span><span class="w">  </span><span class="c1">// 如果 block 不是 modified line，则增加 dirty 计数。因为如果这个时候 block 不是</span>
<span class="linenos">28</span><span class="w">  </span><span class="c1">// modified line，说明这个 block 是 clean line，而现在要写入数据，因此需要将这个</span>
<span class="linenos">29</span><span class="w">  </span><span class="c1">// block 设置为 modified line。这样的话，dirty 计数就需要增加。但如果 block 已经</span>
<span class="linenos">30</span><span class="w">  </span><span class="c1">// 是 modified line，则不需要增加 dirty 计数，因为这个 block 在上次变成 dirty 的</span>
<span class="linenos">31</span><span class="w">  </span><span class="c1">// 时候，dirty 计数已经增加过了。</span>
<span class="linenos">32</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_modified_line</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">33</span><span class="w">    </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">inc_dirty</span><span class="p">();</span>
<span class="linenos">34</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">35</span><span class="w">  </span><span class="c1">// 设置 block 的状态为 modified，即将 block 设置为 MODIFIED。这样的话，下次再有</span>
<span class="linenos">36</span><span class="w">  </span><span class="c1">// 数据请求访问这个 block 的时候，就可以直接从 cache 中读取数据，而不需要再次访问</span>
<span class="linenos">37</span><span class="w">  </span><span class="c1">// 下一级存储。</span>
<span class="linenos">38</span><span class="w">  </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_status</span><span class="p">(</span><span class="n">MODIFIED</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">39</span><span class="w">  </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_byte_mask</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="linenos">40</span><span class="w">  </span><span class="c1">// 更新一个 cache block 的状态为可读。但需要注意的是，这里的可读是指该 sector 可</span>
<span class="linenos">41</span><span class="w">  </span><span class="c1">// 读，而不是整个 block 可读。如果一个 sector 内的所有的 byte mask 位全都设置为</span>
<span class="linenos">42</span><span class="w">  </span><span class="c1">// dirty 了，则将该sector 可设置为可读，因为当前的 sector 已经是全部更新为最新值</span>
<span class="linenos">43</span><span class="w">  </span><span class="c1">// 了，是可读的。这个函数对所有的数据请求 mf 的所有访问的 sector 进行遍历，这里的</span>
<span class="linenos">44</span><span class="w">  </span><span class="c1">// sector 是由 mf 访问的，并由 mf-&gt;get_access_sector_mask() 确定。</span>
<span class="linenos">45</span><span class="w">  </span><span class="n">update_m_readable</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos">46</span>
<span class="linenos">47</span><span class="w">  </span><span class="c1">// generate a write-through</span>
<span class="linenos">48</span><span class="w">  </span><span class="c1">// write-through 策略需要将数据写入 cache 的同时也直接写入下一级存储。这里需要做</span>
<span class="linenos">49</span><span class="w">  </span><span class="c1">// 的是将写请求类型 WRITE_REQUEST_SENT 放入 events，并将数据请求放入当前 cache</span>
<span class="linenos">50</span><span class="w">  </span><span class="c1">// 的 m_miss_queue 中，等待baseline_cache::cycle() 将 m_miss_queue 队首的数</span>
<span class="linenos">51</span><span class="w">  </span><span class="c1">// 据写请求 mf 发送给下一级存储。</span>
<span class="linenos">52</span><span class="w">  </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_REQUEST_SENT</span><span class="p">),</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">53</span>
<span class="linenos">54</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">HIT</span><span class="p">;</span>
<span class="linenos">55</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-wr-hit-we">
<div class="code-block-caption"><span class="caption-number">列表 1.17 </span><span class="caption-text">data_cache::wr_hit_we() 函数</span><a class="headerlink" href="#code-data-cache-wr-hit-we" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="c1">// Write-evict hit: Send request to lower level memory and invalidate</span>
<span class="linenos"> 1</span><span class="c1">// corresponding block</span>
<span class="linenos"> 2</span><span class="cm">/*</span>
<span class="linenos"> 3</span><span class="cm">写逐出命中：向下一级存储发送写回请求并直接逐出相应的 cache block 并设置其无效。</span>
<span class="linenos"> 4</span><span class="cm">*/</span>
<span class="linenos"> 5</span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::wr_hit_we</span><span class="p">(</span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="linenos"> 6</span><span class="w">                                           </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span>
<span class="linenos"> 7</span><span class="w">                                           </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">                                           </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span>
<span class="linenos"> 9</span><span class="w">                                           </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">10</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MISS_QUEUE_FULL</span><span class="p">);</span>
<span class="linenos">12</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span><span class="w">  </span><span class="c1">// cannot handle request this cycle</span>
<span class="linenos">13</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="w">  </span><span class="c1">// generate a write-through/evict</span>
<span class="linenos">16</span><span class="w">  </span><span class="n">cache_block_t</span><span class="w"> </span><span class="o">*</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">get_block</span><span class="p">(</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos">17</span><span class="w">  </span><span class="c1">// write-evict 策略需要将 cache block 直接逐出置为无效的同时也直接写入下一级存</span>
<span class="linenos">18</span><span class="w">  </span><span class="c1">// 储。这里需要做的是将写请求类型 WRITE_REQUEST_SENT 放入 events，并将数据请求</span>
<span class="linenos">19</span><span class="w">  </span><span class="c1">// 放入 m_miss_queue 中，等待baseline_cache::cycle() 将 m_miss_queue 队首的</span>
<span class="linenos">20</span><span class="w">  </span><span class="c1">// 数据写请求 mf 发送给下一级存储。</span>
<span class="linenos">21</span><span class="w">  </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_REQUEST_SENT</span><span class="p">),</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="w">  </span><span class="c1">// Invalidate block</span>
<span class="linenos">24</span><span class="w">  </span><span class="c1">// 写逐出，将 cache block 直接逐出置为无效。</span>
<span class="linenos">25</span><span class="w">  </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_status</span><span class="p">(</span><span class="n">INVALID</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">HIT</span><span class="p">;</span>
<span class="linenos">28</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-wr-hit-global-we-local-wb">
<div class="code-block-caption"><span class="caption-number">列表 1.18 </span><span class="caption-text">data_cache::wr_hit_global_we_local_wb() 函数</span><a class="headerlink" href="#code-data-cache-wr-hit-global-we-local-wb" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="c1">// Global write-evict, local write-back: Useful for private caches</span>
<span class="linenos"> 1</span><span class="cm">/*</span>
<span class="linenos"> 2</span><span class="cm">全局访存采用写逐出，本地访存采用写回。这种策略适用于私有缓存。这个策略比较简单，即只</span>
<span class="linenos"> 3</span><span class="cm">需要判断当前的数据请求是全局访存还是本地访存，然后分别采用写逐出和写回策略即可。</span>
<span class="linenos"> 4</span><span class="cm">*/</span>
<span class="linenos"> 5</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::wr_hit_global_we_local_wb</span><span class="p">(</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 7</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">evict</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span>
<span class="linenos"> 9</span><span class="w">                </span><span class="n">GLOBAL_ACC_W</span><span class="p">);</span><span class="w"> </span><span class="c1">// evict a line that hits on global memory write</span>
<span class="linenos">10</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">evict</span><span class="p">)</span>
<span class="linenos">11</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">wr_hit_we</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span>
<span class="linenos">12</span><span class="w">                    </span><span class="n">status</span><span class="p">);</span><span class="w"> </span><span class="c1">// Write-evict</span>
<span class="linenos">13</span><span class="w">  </span><span class="k">else</span>
<span class="linenos">14</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">wr_hit_wb</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span>
<span class="linenos">15</span><span class="w">                    </span><span class="n">status</span><span class="p">);</span><span class="w"> </span><span class="c1">// Write-back</span>
<span class="linenos">16</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-wr-miss-wa-naive">
<div class="code-block-caption"><span class="caption-number">列表 1.19 </span><span class="caption-text">data_cache::wr_miss_wa_naive() 函数</span><a class="headerlink" href="#code-data-cache-wr-miss-wa-naive" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">  0</span><span class="cm">/****** Write-miss functions (Set by config file) ******/</span>
<span class="linenos">  1</span>
<span class="linenos">  2</span><span class="c1">// Write-allocate miss: Send write request to lower level memory</span>
<span class="linenos">  3</span><span class="c1">// and send a read request for the same block</span>
<span class="linenos">  4</span><span class="cm">/*</span>
<span class="linenos">  5</span><span class="cm">GPGPU-Sim 3.x版本中的naive写分配策略。wr_miss_wa_naive 策略在写 MISS 时，需要先将</span>
<span class="linenos">  6</span><span class="cm">mf 数据包直接写入下一级存储，即它会将 WRITE_REQUEST_SENT 放入 events，并将数据请求</span>
<span class="linenos">  7</span><span class="cm">mf 放入 m_miss_queue 中，等待下一个周期 baseline_cache::cycle() 将 m_miss_queue</span>
<span class="linenos">  8</span><span class="cm">队首的数据包 mf 发送给下一级存储。其次，wr_miss_wa_naive 策略还会将 addr 地址的数据</span>
<span class="linenos">  9</span><span class="cm">读到当前 cache 中，这时候会执行 send_read_request 函数。但是在 send_read_request</span>
<span class="linenos"> 10</span><span class="cm">函数中，很有可能这个读请求需要 evict 一个 block 才可以将新的数据读入到 cache 中，这</span>
<span class="linenos"> 11</span><span class="cm">时候如果 evicted block 是 modified line，则需要将这个 evicted block 写回到下一级</span>
<span class="linenos"> 12</span><span class="cm">存储，这时候会根据 do_miss 和 wb 的值执行 send_write_request 函数。</span>
<span class="linenos"> 13</span><span class="cm">*/</span>
<span class="linenos"> 14</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::wr_miss_wa_naive</span><span class="p">(</span>
<span class="linenos"> 15</span><span class="w">    </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 16</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 17</span><span class="w">  </span><span class="c1">// m_config.block_addr(addr):</span>
<span class="linenos"> 18</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_line_sz - 1);</span>
<span class="linenos"> 19</span><span class="w">  </span><span class="c1">// |-------|-------------|--------------|</span>
<span class="linenos"> 20</span><span class="w">  </span><span class="c1">//            set_index   offset in-line</span>
<span class="linenos"> 21</span><span class="w">  </span><span class="c1">// |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 |</span>
<span class="linenos"> 22</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos"> 23</span><span class="w">  </span><span class="c1">// 1. 如果是 Sector Cache：</span>
<span class="linenos"> 24</span><span class="w">  </span><span class="c1">//  mshr_addr 函数返回 mshr 的地址，该地址即为地址 addr 的 tag 位 + set index</span>
<span class="linenos"> 25</span><span class="w">  </span><span class="c1">//  位 + sector offset 位。即除 single sector byte offset 位 以外的所有位。</span>
<span class="linenos"> 26</span><span class="w">  </span><span class="c1">//  |&lt;----------mshr_addr-----------&gt;|</span>
<span class="linenos"> 27</span><span class="w">  </span><span class="c1">//                     sector offset  off in-sector</span>
<span class="linenos"> 28</span><span class="w">  </span><span class="c1">//                     |-------------|-----------|</span>
<span class="linenos"> 29</span><span class="w">  </span><span class="c1">//                      \                       /</span>
<span class="linenos"> 30</span><span class="w">  </span><span class="c1">//                       \                     /</span>
<span class="linenos"> 31</span><span class="w">  </span><span class="c1">//  |-------|-------------|-------------------|</span>
<span class="linenos"> 32</span><span class="w">  </span><span class="c1">//             set_index     offset in-line</span>
<span class="linenos"> 33</span><span class="w">  </span><span class="c1">//  |&lt;----tag----&gt; 0 0 0 0|</span>
<span class="linenos"> 34</span><span class="w">  </span><span class="c1">// 2. 如果是 Line Cache：</span>
<span class="linenos"> 35</span><span class="w">  </span><span class="c1">//  mshr_addr 函数返回 mshr 的地址，该地址即为地址 addr 的 tag 位 + set index</span>
<span class="linenos"> 36</span><span class="w">  </span><span class="c1">//  位。即除 single line byte off-set 位 以外的所有位。</span>
<span class="linenos"> 37</span><span class="w">  </span><span class="c1">//  |&lt;----mshr_addr---&gt;|</span>
<span class="linenos"> 38</span><span class="w">  </span><span class="c1">//                              line offset</span>
<span class="linenos"> 39</span><span class="w">  </span><span class="c1">//                     |-------------------------|</span>
<span class="linenos"> 40</span><span class="w">  </span><span class="c1">//                      \                       /</span>
<span class="linenos"> 41</span><span class="w">  </span><span class="c1">//                       \                     /</span>
<span class="linenos"> 42</span><span class="w">  </span><span class="c1">//  |-------|-------------|-------------------|</span>
<span class="linenos"> 43</span><span class="w">  </span><span class="c1">//             set_index     offset in-line</span>
<span class="linenos"> 44</span><span class="w">  </span><span class="c1">//  |&lt;----tag----&gt; 0 0 0 0|</span>
<span class="linenos"> 45</span><span class="w">  </span><span class="c1">//</span>
<span class="linenos"> 46</span><span class="w">  </span><span class="c1">// mshr_addr 定义：</span>
<span class="linenos"> 47</span><span class="w">  </span><span class="c1">//   new_addr_type mshr_addr(new_addr_type addr) const {</span>
<span class="linenos"> 48</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_atom_sz - 1);</span>
<span class="linenos"> 49</span><span class="w">  </span><span class="c1">//   }</span>
<span class="linenos"> 50</span><span class="w">  </span><span class="c1">// m_atom_sz = (m_cache_type == SECTOR) ? SECTOR_SIZE : m_line_sz;</span>
<span class="linenos"> 51</span><span class="w">  </span><span class="c1">// 其中 SECTOR_SIZE = const (32 bytes per sector).</span>
<span class="linenos"> 52</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">mshr_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">mshr_addr</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_addr</span><span class="p">());</span>
<span class="linenos"> 53</span>
<span class="linenos"> 54</span><span class="w">  </span><span class="c1">// Write allocate, maximum 3 requests (write miss, read request, write back</span>
<span class="linenos"> 55</span><span class="w">  </span><span class="c1">// request) Conservatively ensure the worst-case request can be handled this</span>
<span class="linenos"> 56</span><span class="w">  </span><span class="c1">// cycle.</span>
<span class="linenos"> 57</span><span class="w">  </span><span class="c1">// MSHR 的 m_data 的 key 中存储了各个合并的地址，probe() 函数主要检查是否命中，</span>
<span class="linenos"> 58</span><span class="w">  </span><span class="c1">// 即主要检查 m_data.keys() 这里面有没有 mshr_addr。</span>
<span class="linenos"> 59</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">probe</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">);</span>
<span class="linenos"> 60</span><span class="w">  </span><span class="c1">// 首先查找是否 MSHR 表中有 block_addr 地址的条目。如果存在该条目（命中 MSHR），</span>
<span class="linenos"> 61</span><span class="w">  </span><span class="c1">// 看是否有空间合并进该条目。如果不存在该条目（未命中 MSHR），看是否有其他空间允</span>
<span class="linenos"> 62</span><span class="w">  </span><span class="c1">// 许添加 mshr_addr 这一条目。</span>
<span class="linenos"> 63</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">mshr_avail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">full</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">);</span>
<span class="linenos"> 64</span><span class="w">  </span><span class="c1">// 在 baseline_cache::cycle() 中，会将 m_miss_queue 队首的数据包 mf 传递给下一</span>
<span class="linenos"> 65</span><span class="w">  </span><span class="c1">// 级存储。因此当遇到 miss 的请求或者写回的请求需要访问下一级存储时，会把 miss 的</span>
<span class="linenos"> 66</span><span class="w">  </span><span class="c1">// 请求放到 m_miss_queue 中。</span>
<span class="linenos"> 67</span><span class="w">  </span><span class="c1">//   bool miss_queue_full(unsigned num_miss) {</span>
<span class="linenos"> 68</span><span class="w">  </span><span class="c1">//     return ((m_miss_queue.size() + num_miss) &gt;= m_config.m_miss_queue_size);</span>
<span class="linenos"> 69</span><span class="w">  </span><span class="c1">//   }</span>
<span class="linenos"> 70</span>
<span class="linenos"> 71</span><span class="w">  </span><span class="c1">// 如果 m_miss_queue.size() 已经不能容下三个数据包的话，有可能无法完成后续动作，</span>
<span class="linenos"> 72</span><span class="w">  </span><span class="c1">// 因为后面最多需要执行三次 send_write_request，在 send_write_request 里每执行</span>
<span class="linenos"> 73</span><span class="w">  </span><span class="c1">// 一次，都需要向 m_miss_queue 添加一个数据包。</span>
<span class="linenos"> 74</span><span class="w">  </span><span class="c1">// Write allocate, maximum 3 requests (write miss, read request, write back</span>
<span class="linenos"> 75</span><span class="w">  </span><span class="c1">// request) Conservatively ensure the worst-case request can be handled this</span>
<span class="linenos"> 76</span><span class="w">  </span><span class="c1">// cycle.</span>
<span class="linenos"> 77</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="linenos"> 78</span><span class="w">      </span><span class="c1">// 如果 miss_queue_full(2) 返回 false，有空余空间支持执行三次 send_write_</span>
<span class="linenos"> 79</span><span class="w">      </span><span class="c1">// request，那么就需要看 MSHR 是否有可用空间。后面这串判断条件其实可以化简成</span>
<span class="linenos"> 80</span><span class="w">      </span><span class="c1">// if (miss_queue_full(2) || !mshr_avail)。</span>
<span class="linenos"> 81</span><span class="w">      </span><span class="c1">// 即符合 RESERVATION_FAIL 的条件：</span>
<span class="linenos"> 82</span><span class="w">      </span><span class="c1">//   1. m_miss_queue 不足以放入三个 WRITE_REQUEST_SENT 请求；</span>
<span class="linenos"> 83</span><span class="w">      </span><span class="c1">//   2. MSHR 不能合并请求（未命中，或者没有可用空间添加新条目）。</span>
<span class="linenos"> 84</span><span class="w">      </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mshr_avail</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos"> 85</span><span class="w">      </span><span class="o">!</span><span class="p">(</span><span class="o">!</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mshr_avail</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos"> 86</span><span class="w">        </span><span class="p">(</span><span class="n">m_miss_queue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">m_miss_queue_size</span><span class="p">))))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 87</span><span class="w">    </span><span class="c1">// check what is the exactly the failure reason</span>
<span class="linenos"> 88</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="linenos"> 89</span><span class="w">      </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MISS_QUEUE_FULL</span><span class="p">);</span>
<span class="linenos"> 90</span><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">mshr_avail</span><span class="p">)</span>
<span class="linenos"> 91</span><span class="w">      </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MSHR_MERGE_ENRTY_FAIL</span><span class="p">);</span>
<span class="linenos"> 92</span><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">mshr_avail</span><span class="p">)</span>
<span class="linenos"> 93</span><span class="w">      </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MSHR_ENRTY_FAIL</span><span class="p">);</span>
<span class="linenos"> 94</span><span class="w">    </span><span class="k">else</span>
<span class="linenos"> 95</span><span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="linenos"> 96</span>
<span class="linenos"> 97</span><span class="w">    </span><span class="c1">// 符合 RESERVATION_FAIL 的条件：</span>
<span class="linenos"> 98</span><span class="w">    </span><span class="c1">//   1. m_miss_queue 不足以放入三个 WRITE_REQUEST_SENT 请求；</span>
<span class="linenos"> 99</span><span class="w">    </span><span class="c1">//   2. MSHR 不能合并请求（未命中，或者没有可用空间添加新条目）。</span>
<span class="linenos">100</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">101</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">102</span>
<span class="linenos">103</span><span class="w">  </span><span class="c1">// send_write_request 执行：</span>
<span class="linenos">104</span><span class="w">  </span><span class="c1">//   events.push_back(request);</span>
<span class="linenos">105</span><span class="w">  </span><span class="c1">//   // 在 baseline_cache::cycle() 中，会将 m_miss_queue 队首的数据包 mf 传递</span>
<span class="linenos">106</span><span class="w">  </span><span class="c1">//   // 给下一级存储。</span>
<span class="linenos">107</span><span class="w">  </span><span class="c1">//   m_miss_queue.push_back(mf);</span>
<span class="linenos">108</span><span class="w">  </span><span class="c1">//   mf-&gt;set_status(m_miss_queue_status, time);</span>
<span class="linenos">109</span><span class="w">  </span><span class="c1">// wr_miss_wa_naive 策略在写 MISS 时，需要先将 mf 数据包直接写入下一级存储，即它</span>
<span class="linenos">110</span><span class="w">  </span><span class="c1">// 会将 WRITE_REQUEST_SENT 放入 events，并将数据请求 mf 放入 m_miss_queue 中，</span>
<span class="linenos">111</span><span class="w">  </span><span class="c1">// 等待下一个周期 baseline_cache::cycle() 将 m_miss_queue 队首的数据包 mf 发送</span>
<span class="linenos">112</span><span class="w">  </span><span class="c1">// 给下一级存储。其次，wr_miss_wa_naive 策略还会将 addr 地址的数据读到当前 cache</span>
<span class="linenos">113</span><span class="w">  </span><span class="c1">// 中，这时候会执行 send_read_request 函数。但是在 send_read_request 函数中，很</span>
<span class="linenos">114</span><span class="w">  </span><span class="c1">// 有可能这个读请求需要 evict 一个 block 才可以将新的数据读入到 cache 中，这时候</span>
<span class="linenos">115</span><span class="w">  </span><span class="c1">// 如果 evicted block 是 modified line，则需要将这个 evicted block 写回到下一级</span>
<span class="linenos">116</span><span class="w">  </span><span class="c1">// 存储，这时候会根据 do_miss 和 wb 的值执行 send_write_request 函数。</span>
<span class="linenos">117</span><span class="w">  </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_REQUEST_SENT</span><span class="p">),</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">118</span><span class="w">  </span><span class="c1">// Tries to send write allocate request, returns true on success and false on</span>
<span class="linenos">119</span><span class="w">  </span><span class="c1">// failure</span>
<span class="linenos">120</span><span class="w">  </span><span class="c1">// if(!send_write_allocate(mf, addr, block_addr, cache_index, time, events))</span>
<span class="linenos">121</span><span class="w">  </span><span class="c1">//    return RESERVATION_FAIL;</span>
<span class="linenos">122</span>
<span class="linenos">123</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">mem_access_t</span><span class="w"> </span><span class="o">*</span><span class="n">ma</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">124</span><span class="w">      </span><span class="n">new</span><span class="w"> </span><span class="n">mem_access_t</span><span class="p">(</span><span class="n">m_wr_alloc_type</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_addr</span><span class="p">(),</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">get_atom_sz</span><span class="p">(),</span>
<span class="linenos">125</span><span class="w">                      </span><span class="nb">false</span><span class="p">,</span><span class="w">  </span><span class="c1">// Now performing a read</span>
<span class="linenos">126</span><span class="w">                      </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_warp_mask</span><span class="p">(),</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_byte_mask</span><span class="p">(),</span>
<span class="linenos">127</span><span class="w">                      </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">(),</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpgpu_ctx</span><span class="p">);</span>
<span class="linenos">128</span>
<span class="linenos">129</span><span class="w">  </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">n_mf</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">130</span><span class="w">      </span><span class="n">new</span><span class="w"> </span><span class="n">mem_fetch</span><span class="p">(</span><span class="o">*</span><span class="n">ma</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_ctrl_size</span><span class="p">(),</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_wid</span><span class="p">(),</span>
<span class="linenos">131</span><span class="w">                    </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_sid</span><span class="p">(),</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tpc</span><span class="p">(),</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_mem_config</span><span class="p">(),</span>
<span class="linenos">132</span><span class="w">                    </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_tot_sim_cycle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_sim_cycle</span><span class="p">);</span>
<span class="linenos">133</span>
<span class="linenos">134</span><span class="w">  </span><span class="c1">// 标识是否请求被填充进 MSHR 或者 被放到 m_miss_queue 以在下一个周期发送到下一</span>
<span class="linenos">135</span><span class="w">  </span><span class="c1">// 级存储。</span>
<span class="linenos">136</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_miss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos">137</span><span class="w">  </span><span class="c1">// wb 变量标识 tag_array::access() 函数中，如果下面的 send_read_request 函数</span>
<span class="linenos">138</span><span class="w">  </span><span class="c1">// 发生 MISS，则需要逐出一个 block，并将这个 evicted block 写回到下一级存储。</span>
<span class="linenos">139</span><span class="w">  </span><span class="c1">// 如果这个 block 已经是 modified line，则 wb 为 true，因为在将其分配给新访问</span>
<span class="linenos">140</span><span class="w">  </span><span class="c1">// 之前，必须将这个已经 modified 的 block 写回到下一级存储。但如果这个 block</span>
<span class="linenos">141</span><span class="w">  </span><span class="c1">// 是 clean line，则 wb 为 false，因为这个 block 不需要写回到下一级存储。这个</span>
<span class="linenos">142</span><span class="w">  </span><span class="c1">// evicted block 的信息被设置在 evicted 中。</span>
<span class="linenos">143</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos">144</span><span class="w">  </span><span class="n">evicted_block_info</span><span class="w"> </span><span class="n">evicted</span><span class="p">;</span>
<span class="linenos">145</span>
<span class="linenos">146</span><span class="w">  </span><span class="c1">// Send read request resulting from write miss</span>
<span class="linenos">147</span><span class="w">  </span><span class="n">send_read_request</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">n_mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">do_miss</span><span class="p">,</span><span class="w"> </span><span class="n">wb</span><span class="p">,</span>
<span class="linenos">148</span><span class="w">                    </span><span class="n">evicted</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="linenos">149</span>
<span class="linenos">150</span><span class="w">  </span><span class="n">events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_ALLOCATE_SENT</span><span class="p">));</span>
<span class="linenos">151</span>
<span class="linenos">152</span><span class="w">  </span><span class="c1">// do_miss 标识是否请求被填充进 MSHR 或者 被放到 m_miss_queue 以在下一个周期</span>
<span class="linenos">153</span><span class="w">  </span><span class="c1">// 发送到下一级存储。</span>
<span class="linenos">154</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">do_miss</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">155</span><span class="w">    </span><span class="c1">// If evicted block is modified and not a write-through</span>
<span class="linenos">156</span><span class="w">    </span><span class="c1">// (already modified lower level)</span>
<span class="linenos">157</span><span class="w">    </span><span class="c1">// wb 变量标识 tag_array::access() 函数中，如果下面的 send_read_request 函</span>
<span class="linenos">158</span><span class="w">    </span><span class="c1">// 数发生 MISS，则需要逐出一个 block，并将这个 evicted block 写回到下一级存</span>
<span class="linenos">159</span><span class="w">    </span><span class="c1">// 储。如果这个 block 已经是 modified line，则 wb 为 true，因为在将其分配给</span>
<span class="linenos">160</span><span class="w">    </span><span class="c1">// 新访问之前，必须将这个已经 modified 的 block 写回到下一级存储。但如果这个</span>
<span class="linenos">161</span><span class="w">    </span><span class="c1">// block 是 clean line，则 wb 为 false，因为这个 block 不需要写回到下一级存</span>
<span class="linenos">162</span><span class="w">    </span><span class="c1">// 储。这个 evicted block 的信息被设置在 evicted 中。</span>
<span class="linenos">163</span><span class="w">    </span><span class="c1">// 这里如果 cache 的写策略为写直达，就不需要在读 miss 时将被逐出的 MODIFIED</span>
<span class="linenos">164</span><span class="w">    </span><span class="c1">// cache block 写回到下一级存储，因为这个 cache block 在被 MODIFIED 的时候</span>
<span class="linenos">165</span><span class="w">    </span><span class="c1">// 已经被 write-through 到下一级存储了。</span>
<span class="linenos">166</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wb</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_write_policy</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WRITE_THROUGH</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">167</span><span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span>
<span class="linenos">168</span><span class="w">            </span><span class="n">MISS</span><span class="p">);</span><span class="w"> </span><span class="c1">// SECTOR_MISS and HIT_RESERVED should not send write back</span>
<span class="linenos">169</span><span class="w">      </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_memfetch_creator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span>
<span class="linenos">170</span><span class="w">          </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">m_wrbk_type</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_warp_mask</span><span class="p">(),</span>
<span class="linenos">171</span><span class="w">          </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_byte_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_sector_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_modified_size</span><span class="p">,</span>
<span class="linenos">172</span><span class="w">          </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_tot_sim_cycle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_sim_cycle</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span>
<span class="linenos">173</span><span class="w">          </span><span class="nb">NULL</span><span class="p">);</span>
<span class="linenos">174</span><span class="w">      </span><span class="c1">// the evicted block may have wrong chip id when advanced L2 hashing  is</span>
<span class="linenos">175</span><span class="w">      </span><span class="c1">// used, so set the right chip address from the original mf</span>
<span class="linenos">176</span><span class="w">      </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_chip</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">chip</span><span class="p">);</span>
<span class="linenos">177</span><span class="w">      </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_partition</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">sub_partition</span><span class="p">);</span>
<span class="linenos">178</span><span class="w">      </span><span class="c1">// 将 tag_array::access() 函数中逐出的 evicted block 写回到下一级存储。</span>
<span class="linenos">179</span><span class="w">      </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_BACK_REQUEST_SENT</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">),</span>
<span class="linenos">180</span><span class="w">                        </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">181</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">182</span><span class="w">    </span><span class="c1">// 如果 do_miss 为 true，表示请求被填充进 MSHR 或者 被放到 m_miss_queue 以在</span>
<span class="linenos">183</span><span class="w">    </span><span class="c1">// 下一个周期发送到下一级存储。即整个写 MISS 处理函数的所有过程全部完成，返回的</span>
<span class="linenos">184</span><span class="w">    </span><span class="c1">// 是 write miss 这个原始写请求的状态。</span>
<span class="linenos">185</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MISS</span><span class="p">;</span>
<span class="linenos">186</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">187</span>
<span class="linenos">188</span><span class="w">  </span><span class="c1">// 如果 do_miss 为 false，表示请求未被填充进 MSHR 或者 未被放到 m_miss_queue 以</span>
<span class="linenos">189</span><span class="w">  </span><span class="c1">// 在下一个周期发送到下一级存储。即整个写 MISS 处理函数没有将读请求发送出去，因此</span>
<span class="linenos">190</span><span class="w">  </span><span class="c1">// 返回 RESERVATION_FAIL。</span>
<span class="linenos">191</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">192</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-wr-miss-no-wa">
<div class="code-block-caption"><span class="caption-number">列表 1.20 </span><span class="caption-text">data_cache::wr_miss_no_wa() 函数</span><a class="headerlink" href="#code-data-cache-wr-miss-no-wa" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 0</span><span class="c1">// No write-allocate miss: Simply send write request to lower level memory</span>
<span class="linenos"> 1</span><span class="cm">/*</span>
<span class="linenos"> 2</span><span class="cm">No write-allocate miss，这个处理函数仅仅简单地将写请求发送到下一级存储。</span>
<span class="linenos"> 3</span><span class="cm">*/</span>
<span class="linenos"> 4</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::wr_miss_no_wa</span><span class="p">(</span>
<span class="linenos"> 5</span><span class="w">    </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="c1">// 如果 m_miss_queue.size() 已经不能容下一个数据包的话，有可能无法完成后续动作，</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="c1">// 因为后面最多需要执行一次 send_write_request，在 send_write_request 里每执行</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="c1">// 一次，都需要向 m_miss_queue 添加一个数据包。</span>
<span class="linenos">10</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MISS_QUEUE_FULL</span><span class="p">);</span>
<span class="linenos">12</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span><span class="w">  </span><span class="c1">// cannot handle request this cycle</span>
<span class="linenos">13</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="w">  </span><span class="c1">// on miss, generate write through (no write buffering -- too many threads</span>
<span class="linenos">16</span><span class="w">  </span><span class="c1">// for that)</span>
<span class="linenos">17</span><span class="w">  </span><span class="c1">// send_write_request 执行：</span>
<span class="linenos">18</span><span class="w">  </span><span class="c1">//   events.push_back(request);</span>
<span class="linenos">19</span><span class="w">  </span><span class="c1">//   // 在 baseline_cache::cycle() 中，会将 m_miss_queue 队首的数据包 mf 传递</span>
<span class="linenos">20</span><span class="w">  </span><span class="c1">//   // 给下一级存储。</span>
<span class="linenos">21</span><span class="w">  </span><span class="c1">//   m_miss_queue.push_back(mf);</span>
<span class="linenos">22</span><span class="w">  </span><span class="c1">//   mf-&gt;set_status(m_miss_queue_status, time);</span>
<span class="linenos">23</span><span class="w">  </span><span class="c1">// No write-allocate miss 策略在写 MISS 时，直接将 mf 数据包直接写入下一级存储。</span>
<span class="linenos">24</span><span class="w">  </span><span class="c1">// 这里需要做的是将写请求类型 WRITE_REQUEST_SENT 放入 events，并将数据请求放入</span>
<span class="linenos">25</span><span class="w">  </span><span class="c1">// m_miss_queue 中，等待baseline_cache::cycle() 将 m_miss_queue 队首的数据写</span>
<span class="linenos">26</span><span class="w">  </span><span class="c1">// 请求 mf 发送给下一级存储。</span>
<span class="linenos">27</span><span class="w">  </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_REQUEST_SENT</span><span class="p">),</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MISS</span><span class="p">;</span>
<span class="linenos">30</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-wr-miss-wa-fetch-on-write">
<div class="code-block-caption"><span class="caption-number">列表 1.21 </span><span class="caption-text">data_cache::wr_miss_wa_fetch_on_write() 函数</span><a class="headerlink" href="#code-data-cache-wr-miss-wa-fetch-on-write" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">  0</span><span class="cm">/*</span>
<span class="linenos">  1</span><span class="cm">write_allocated_fetch_on_write 策略，在写入时读取策略中，当写入 sector 的单个字节</span>
<span class="linenos">  2</span><span class="cm">时，L2 会读取整个 sector ，然后将写入的部分合并到该 sector ，并将该 sector 设置为已</span>
<span class="linenos">  3</span><span class="cm">修改。</span>
<span class="linenos">  4</span><span class="cm">*/</span>
<span class="linenos">  5</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::wr_miss_wa_fetch_on_write</span><span class="p">(</span>
<span class="linenos">  6</span><span class="w">    </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos">  7</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">  8</span><span class="w">  </span><span class="c1">// m_config.block_addr(addr):</span>
<span class="linenos">  9</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_line_sz - 1);</span>
<span class="linenos"> 10</span><span class="w">  </span><span class="c1">// |-------|-------------|--------------|</span>
<span class="linenos"> 11</span><span class="w">  </span><span class="c1">//            set_index   offset in-line</span>
<span class="linenos"> 12</span><span class="w">  </span><span class="c1">// |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 |</span>
<span class="linenos"> 13</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos"> 14</span><span class="w">  </span><span class="c1">// 1. 如果是 Sector Cache：</span>
<span class="linenos"> 15</span><span class="w">  </span><span class="c1">//  mshr_addr 函数返回 mshr 的地址，该地址即为地址 addr 的 tag 位 + set index</span>
<span class="linenos"> 16</span><span class="w">  </span><span class="c1">//  位 + sector offset 位。即除 single sector byte offset 位 以外的所有位。</span>
<span class="linenos"> 17</span><span class="w">  </span><span class="c1">//  |&lt;----------mshr_addr-----------&gt;|</span>
<span class="linenos"> 18</span><span class="w">  </span><span class="c1">//                     sector offset  off in-sector</span>
<span class="linenos"> 19</span><span class="w">  </span><span class="c1">//                     |-------------|-----------|</span>
<span class="linenos"> 20</span><span class="w">  </span><span class="c1">//                      \                       /</span>
<span class="linenos"> 21</span><span class="w">  </span><span class="c1">//                       \                     /</span>
<span class="linenos"> 22</span><span class="w">  </span><span class="c1">//  |-------|-------------|-------------------|</span>
<span class="linenos"> 23</span><span class="w">  </span><span class="c1">//             set_index     offset in-line</span>
<span class="linenos"> 24</span><span class="w">  </span><span class="c1">//  |&lt;----tag----&gt; 0 0 0 0|</span>
<span class="linenos"> 25</span><span class="w">  </span><span class="c1">// 2. 如果是 Line Cache：</span>
<span class="linenos"> 26</span><span class="w">  </span><span class="c1">//  mshr_addr 函数返回 mshr 的地址，该地址即为地址 addr 的 tag 位 + set index</span>
<span class="linenos"> 27</span><span class="w">  </span><span class="c1">//  位。即除 single line byte off-set 位 以外的所有位。</span>
<span class="linenos"> 28</span><span class="w">  </span><span class="c1">//  |&lt;----mshr_addr---&gt;|</span>
<span class="linenos"> 29</span><span class="w">  </span><span class="c1">//                              line offset</span>
<span class="linenos"> 30</span><span class="w">  </span><span class="c1">//                     |-------------------------|</span>
<span class="linenos"> 31</span><span class="w">  </span><span class="c1">//                      \                       /</span>
<span class="linenos"> 32</span><span class="w">  </span><span class="c1">//                       \                     /</span>
<span class="linenos"> 33</span><span class="w">  </span><span class="c1">//  |-------|-------------|-------------------|</span>
<span class="linenos"> 34</span><span class="w">  </span><span class="c1">//             set_index     offset in-line</span>
<span class="linenos"> 35</span><span class="w">  </span><span class="c1">//  |&lt;----tag----&gt; 0 0 0 0|</span>
<span class="linenos"> 36</span><span class="w">  </span><span class="c1">//</span>
<span class="linenos"> 37</span><span class="w">  </span><span class="c1">// mshr_addr 定义：</span>
<span class="linenos"> 38</span><span class="w">  </span><span class="c1">//   new_addr_type mshr_addr(new_addr_type addr) const {</span>
<span class="linenos"> 39</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_atom_sz - 1);</span>
<span class="linenos"> 40</span><span class="w">  </span><span class="c1">//   }</span>
<span class="linenos"> 41</span><span class="w">  </span><span class="c1">// m_atom_sz = (m_cache_type == SECTOR) ? SECTOR_SIZE : m_line_sz;</span>
<span class="linenos"> 42</span><span class="w">  </span><span class="c1">// 其中 SECTOR_SIZE = const (32 bytes per sector).</span>
<span class="linenos"> 43</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">mshr_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">mshr_addr</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_addr</span><span class="p">());</span>
<span class="linenos"> 44</span>
<span class="linenos"> 45</span><span class="w">  </span><span class="c1">// 如果请求写入的字节数等于整个 cache line/sector 的大小，那么直接写入 cache，并</span>
<span class="linenos"> 46</span><span class="w">  </span><span class="c1">// 将 cache 设置为 MODIFIED，而不需要发送读请求到下一级存储。</span>
<span class="linenos"> 47</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_byte_mask</span><span class="p">().</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">get_atom_sz</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 48</span><span class="w">    </span><span class="c1">// if the request writes to the whole cache line/sector, then, write and</span>
<span class="linenos"> 49</span><span class="w">    </span><span class="c1">// set cache line Modified. and no need to send read request to memory or</span>
<span class="linenos"> 50</span><span class="w">    </span><span class="c1">// reserve mshr.</span>
<span class="linenos"> 51</span><span class="w">    </span><span class="c1">// 如果 m_miss_queue.size() 已经不能容下一个数据包的话，有可能无法完成后续动</span>
<span class="linenos"> 52</span><span class="w">    </span><span class="c1">// 作，因为后面最多需要执行一次 send_write_request，在 send_write_request 里</span>
<span class="linenos"> 53</span><span class="w">    </span><span class="c1">// 每执行一次，都需要向 m_miss_queue 添加一个数据包。</span>
<span class="linenos"> 54</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 55</span><span class="w">      </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MISS_QUEUE_FULL</span><span class="p">);</span>
<span class="linenos"> 56</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span><span class="w">  </span><span class="c1">// cannot handle request this cycle</span>
<span class="linenos"> 57</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 58</span><span class="w">    </span><span class="c1">// wb 变量标识 tag_array::access() 函数中，如果下面的 send_read_request 函数</span>
<span class="linenos"> 59</span><span class="w">    </span><span class="c1">// 发生 MISS，则需要逐出一个 block，并将这个 evicted block 写回到下一级存储。</span>
<span class="linenos"> 60</span><span class="w">    </span><span class="c1">// 如果这个 block 已经是 modified line，则 wb 为 true，因为在将其分配给新访问</span>
<span class="linenos"> 61</span><span class="w">    </span><span class="c1">// 之前，必须将这个已经 modified 的 block 写回到下一级存储。但如果这个 block</span>
<span class="linenos"> 62</span><span class="w">    </span><span class="c1">// 是 clean line，则 wb 为 false，因为这个 block 不需要写回到下一级存储。这个</span>
<span class="linenos"> 63</span><span class="w">    </span><span class="c1">// evicted block 的信息被设置在 evicted 中。</span>
<span class="linenos"> 64</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos"> 65</span><span class="w">    </span><span class="n">evicted_block_info</span><span class="w"> </span><span class="n">evicted</span><span class="p">;</span>
<span class="linenos"> 66</span><span class="w">    </span><span class="c1">// 更新 tag_array 的状态，包括更新 LRU 状态，设置逐出的 block 或 sector 等。</span>
<span class="linenos"> 67</span><span class="w">    </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span>
<span class="linenos"> 68</span><span class="w">        </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 69</span><span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">HIT</span><span class="p">);</span>
<span class="linenos"> 70</span><span class="w">    </span><span class="n">cache_block_t</span><span class="w"> </span><span class="o">*</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">get_block</span><span class="p">(</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos"> 71</span><span class="w">    </span><span class="c1">// 如果 block 不是 modified line，则增加 dirty 计数。因为如果这个时候 block 不</span>
<span class="linenos"> 72</span><span class="w">    </span><span class="c1">// 是 modified line，说明这个 block 是 clean line，而现在要写入数据，因此需要将</span>
<span class="linenos"> 73</span><span class="w">    </span><span class="c1">// 这个 block 设置为 modified line。这样的话，dirty 计数就需要增加。但若 block</span>
<span class="linenos"> 74</span><span class="w">    </span><span class="c1">// 已经是 modified line，则不需要增加 dirty 计数，这个 block 在上次变成 dirty</span>
<span class="linenos"> 75</span><span class="w">    </span><span class="c1">// 的时候，dirty 计数已经增加过了。</span>
<span class="linenos"> 76</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_modified_line</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 77</span><span class="w">      </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">inc_dirty</span><span class="p">();</span>
<span class="linenos"> 78</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 79</span><span class="w">    </span><span class="c1">// 设置 block 的状态为 modified，即将 block 设置为 MODIFIED。这样的话，下次再</span>
<span class="linenos"> 80</span><span class="w">    </span><span class="c1">// 有数据请求访问这个 block 的时候，就可以直接从 cache 中读取数据，而不需要再次</span>
<span class="linenos"> 81</span><span class="w">    </span><span class="c1">// 访问下一级存储。</span>
<span class="linenos"> 82</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_status</span><span class="p">(</span><span class="n">MODIFIED</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos"> 83</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_byte_mask</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 84</span>
<span class="linenos"> 85</span><span class="w">    </span><span class="c1">// 暂时不用关心这个函数。</span>
<span class="linenos"> 86</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">HIT_RESERVED</span><span class="p">)</span>
<span class="linenos"> 87</span><span class="w">      </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_ignore_on_fill</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos"> 88</span>
<span class="linenos"> 89</span><span class="w">    </span><span class="c1">// 只要 m_tag_array-&gt;access 返回的状态不是 RESERVATION_FAIL，就说明或者发生了</span>
<span class="linenos"> 90</span><span class="w">    </span><span class="c1">// HIT_RESERVED，或者 SECTOR_MISS，又或者 MISS。这里只要不是 RESERVATION_FAIL，</span>
<span class="linenos"> 91</span><span class="w">    </span><span class="c1">// 就代表有 cache block 被分配了，因此要根据这个被逐出的 cache block 是否需要写</span>
<span class="linenos"> 92</span><span class="w">    </span><span class="c1">// 回，将这个 block 写回到下一级存储。</span>
<span class="linenos"> 93</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 94</span><span class="w">      </span><span class="c1">// If evicted block is modified and not a write-through</span>
<span class="linenos"> 95</span><span class="w">      </span><span class="c1">// (already modified lower level)</span>
<span class="linenos"> 96</span><span class="w">      </span><span class="c1">// wb 变量标识 tag_array::access() 函数中，如果上面的 m_tag_array-&gt;access</span>
<span class="linenos"> 97</span><span class="w">      </span><span class="c1">// 函数发生 MISS，则需要逐出一个 block，并将这个 evicted block 写回到下一级</span>
<span class="linenos"> 98</span><span class="w">      </span><span class="c1">// 存储。如果这个 block 已经是 modified line，则 wb 为 true，因为在将其分配</span>
<span class="linenos"> 99</span><span class="w">      </span><span class="c1">// 给新访问之前，必须将这个已经 modified 的 block 写回到下一级存储。但如果这</span>
<span class="linenos">100</span><span class="w">      </span><span class="c1">// 个 block 是 clean line，则 wb 为 false，因为这个 block 不需要写回到下一</span>
<span class="linenos">101</span><span class="w">      </span><span class="c1">// 级存储。这个 evicted block 的信息被设置在 evicted 中。</span>
<span class="linenos">102</span><span class="w">      </span><span class="c1">// 这里如果 cache 的写策略为写直达，就不需要在读 miss 时将被逐出的 MODIFIED</span>
<span class="linenos">103</span><span class="w">      </span><span class="c1">// cache block 写回到下一级存储，因为这个 cache block 在被 MODIFIED 的时候</span>
<span class="linenos">104</span><span class="w">      </span><span class="c1">// 已经被 write-through 到下一级存储了。</span>
<span class="linenos">105</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wb</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_write_policy</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WRITE_THROUGH</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">106</span><span class="w">        </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_memfetch_creator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span>
<span class="linenos">107</span><span class="w">            </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">m_wrbk_type</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_warp_mask</span><span class="p">(),</span>
<span class="linenos">108</span><span class="w">            </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_byte_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_sector_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_modified_size</span><span class="p">,</span>
<span class="linenos">109</span><span class="w">            </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_tot_sim_cycle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_sim_cycle</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span>
<span class="linenos">110</span><span class="w">            </span><span class="nb">NULL</span><span class="p">);</span>
<span class="linenos">111</span><span class="w">        </span><span class="c1">// the evicted block may have wrong chip id when advanced L2 hashing  is</span>
<span class="linenos">112</span><span class="w">        </span><span class="c1">// used, so set the right chip address from the original mf</span>
<span class="linenos">113</span><span class="w">        </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_chip</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">chip</span><span class="p">);</span>
<span class="linenos">114</span><span class="w">        </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_partition</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">sub_partition</span><span class="p">);</span>
<span class="linenos">115</span><span class="w">        </span><span class="c1">// 写回 evicted block 到下一级存储。</span>
<span class="linenos">116</span><span class="w">        </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_BACK_REQUEST_SENT</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">),</span>
<span class="linenos">117</span><span class="w">                          </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">118</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">119</span><span class="w">      </span><span class="c1">// 整个写 MISS 处理函数的所有过程全部完成，返回的是 write miss 这个原始写请求</span>
<span class="linenos">120</span><span class="w">      </span><span class="c1">// 的状态。</span>
<span class="linenos">121</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">MISS</span><span class="p">;</span>
<span class="linenos">122</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">123</span><span class="w">    </span><span class="c1">// 整个写 MISS 处理函数没有分配新的 cache block，并将逐出的 block 写回，因此返</span>
<span class="linenos">124</span><span class="w">    </span><span class="c1">// 回 RESERVATION_FAIL。</span>
<span class="linenos">125</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">126</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">127</span><span class="w">    </span><span class="c1">// 如果请求写入的字节数小于整个 cache line/sector 的大小，那么需要发送读请求到</span>
<span class="linenos">128</span><span class="w">    </span><span class="c1">// 下一级存储，然后将写入的部分合并到该 sector ，并将该 sector 设置为已修改。</span>
<span class="linenos">129</span>
<span class="linenos">130</span><span class="w">    </span><span class="c1">// MSHR 的 m_data 的 key 中存储了各个合并的地址，probe() 函数主要检查是否命中，</span>
<span class="linenos">131</span><span class="w">    </span><span class="c1">// 即主要检查 m_data.keys() 这里面有没有 mshr_addr。</span>
<span class="linenos">132</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">probe</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">);</span>
<span class="linenos">133</span><span class="w">    </span><span class="c1">// 首先查找是否 MSHR 表中有 block_addr 地址的条目。如果存在该条目（命中</span>
<span class="linenos">134</span><span class="w">    </span><span class="c1">// MSHR），看是否有空间合并进该条目。如果不存在该条目（未命中 MSHR），看</span>
<span class="linenos">135</span><span class="w">    </span><span class="c1">// 是否有其他空间允许添加 mshr_addr 这一条目。</span>
<span class="linenos">136</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">mshr_avail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">full</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">);</span>
<span class="linenos">137</span><span class="w">    </span><span class="c1">// 如果 m_miss_queue.size() 已经不能容下两个数据包的话，有可能无法完成后续</span>
<span class="linenos">138</span><span class="w">    </span><span class="c1">// 动作，因为后面最多需要执行一次 send_read_request 和一次 send_write_request，</span>
<span class="linenos">139</span><span class="w">    </span><span class="c1">// 这两次有可能最多需要向 m_miss_queue 添加两个数据包。</span>
<span class="linenos">140</span><span class="w">    </span><span class="c1">// 若 miss_queue_full(1) 返回 false，有空余空间支持执行一次 send_write_request</span>
<span class="linenos">141</span><span class="w">    </span><span class="c1">// 和一次 send_read_request，那么就需要看 MSHR 是否有可用空间。后面这串判断条件</span>
<span class="linenos">142</span><span class="w">    </span><span class="c1">// 其实可以化简成：</span>
<span class="linenos">143</span><span class="w">    </span><span class="c1">//   if (miss_queue_full(1) || !mshr_avail)。</span>
<span class="linenos">144</span><span class="w">    </span><span class="c1">// 即符合 RESERVATION_FAIL 的条件：</span>
<span class="linenos">145</span><span class="w">    </span><span class="c1">//   1. m_miss_queue 不足以放入一个读一个写，共两个请求；</span>
<span class="linenos">146</span><span class="w">    </span><span class="c1">//   2. MSHR 不能合并请求（未命中，或者没有可用空间添加新条目）。</span>
<span class="linenos">147</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="linenos">148</span><span class="w">        </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mshr_avail</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos">149</span><span class="w">        </span><span class="o">!</span><span class="p">(</span><span class="o">!</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mshr_avail</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos">150</span><span class="w">          </span><span class="p">(</span><span class="n">m_miss_queue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">m_miss_queue_size</span><span class="p">))))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">151</span><span class="w">      </span><span class="c1">// check what is the exactly the failure reason</span>
<span class="linenos">152</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="linenos">153</span><span class="w">        </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MISS_QUEUE_FULL</span><span class="p">);</span>
<span class="linenos">154</span><span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">mshr_avail</span><span class="p">)</span>
<span class="linenos">155</span><span class="w">        </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MSHR_MERGE_ENRTY_FAIL</span><span class="p">);</span>
<span class="linenos">156</span><span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mshr_hit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">mshr_avail</span><span class="p">)</span>
<span class="linenos">157</span><span class="w">        </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MSHR_ENRTY_FAIL</span><span class="p">);</span>
<span class="linenos">158</span><span class="w">      </span><span class="k">else</span>
<span class="linenos">159</span><span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="linenos">160</span>
<span class="linenos">161</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">162</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">163</span>
<span class="linenos">164</span><span class="w">    </span><span class="c1">// prevent Write - Read - Write in pending mshr</span>
<span class="linenos">165</span><span class="w">    </span><span class="c1">// allowing another write will override the value of the first write, and</span>
<span class="linenos">166</span><span class="w">    </span><span class="c1">// the pending read request will read incorrect result from the second write</span>
<span class="linenos">167</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">probe</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos">168</span><span class="w">        </span><span class="n">m_mshrs</span><span class="p">.</span><span class="n">is_read_after_write_pending</span><span class="p">(</span><span class="n">mshr_addr</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">is_write</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">169</span><span class="w">      </span><span class="c1">// assert(0);</span>
<span class="linenos">170</span><span class="w">      </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MSHR_RW_PENDING</span><span class="p">);</span>
<span class="linenos">171</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">172</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">173</span>
<span class="linenos">174</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">mem_access_t</span><span class="w"> </span><span class="o">*</span><span class="n">ma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">mem_access_t</span><span class="p">(</span>
<span class="linenos">175</span><span class="w">        </span><span class="n">m_wr_alloc_type</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_addr</span><span class="p">(),</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">get_atom_sz</span><span class="p">(),</span>
<span class="linenos">176</span><span class="w">        </span><span class="nb">false</span><span class="p">,</span><span class="w">  </span><span class="c1">// Now performing a read</span>
<span class="linenos">177</span><span class="w">        </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_warp_mask</span><span class="p">(),</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_byte_mask</span><span class="p">(),</span>
<span class="linenos">178</span><span class="w">        </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">(),</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpgpu_ctx</span><span class="p">);</span>
<span class="linenos">179</span>
<span class="linenos">180</span><span class="w">    </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">n_mf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">mem_fetch</span><span class="p">(</span>
<span class="linenos">181</span><span class="w">        </span><span class="o">*</span><span class="n">ma</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_ctrl_size</span><span class="p">(),</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_wid</span><span class="p">(),</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_sid</span><span class="p">(),</span>
<span class="linenos">182</span><span class="w">        </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tpc</span><span class="p">(),</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_mem_config</span><span class="p">(),</span>
<span class="linenos">183</span><span class="w">        </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_tot_sim_cycle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_sim_cycle</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos">184</span>
<span class="linenos">185</span><span class="w">    </span><span class="c1">// m_config.block_addr(addr):</span>
<span class="linenos">186</span><span class="w">    </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_line_sz - 1);</span>
<span class="linenos">187</span><span class="w">    </span><span class="c1">// |-------|-------------|--------------|</span>
<span class="linenos">188</span><span class="w">    </span><span class="c1">//            set_index   offset in-line</span>
<span class="linenos">189</span><span class="w">    </span><span class="c1">// |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 |</span>
<span class="linenos">190</span><span class="w">    </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos">191</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_miss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos">192</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos">193</span><span class="w">    </span><span class="n">evicted_block_info</span><span class="w"> </span><span class="n">evicted</span><span class="p">;</span>
<span class="linenos">194</span><span class="w">    </span><span class="c1">// 发送读请求到下一级存储，然后将写入的部分合并到该 sector ，并将该 sector 设</span>
<span class="linenos">195</span><span class="w">    </span><span class="c1">// 置为已修改。</span>
<span class="linenos">196</span><span class="w">    </span><span class="n">send_read_request</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">n_mf</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">do_miss</span><span class="p">,</span><span class="w"> </span><span class="n">wb</span><span class="p">,</span>
<span class="linenos">197</span><span class="w">                      </span><span class="n">evicted</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="linenos">198</span>
<span class="linenos">199</span><span class="w">    </span><span class="n">cache_block_t</span><span class="w"> </span><span class="o">*</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">get_block</span><span class="p">(</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos">200</span><span class="w">    </span><span class="c1">// 将 block 设置为在下次 fill 时，置为 MODIFIED。这样的话，下次再有数据请求填</span>
<span class="linenos">201</span><span class="w">    </span><span class="c1">// 入 fill 时：</span>
<span class="linenos">202</span><span class="w">    </span><span class="c1">//   m_status = m_set_modified_on_fill ? MODIFIED : VALID; 或</span>
<span class="linenos">203</span><span class="w">    </span><span class="c1">//   m_status[sidx] = m_set_modified_on_fill[sidx] ? MODIFIED : VALID;</span>
<span class="linenos">204</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_modified_on_fill</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">205</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_byte_mask_on_fill</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="linenos">206</span>
<span class="linenos">207</span><span class="w">    </span><span class="n">events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_ALLOCATE_SENT</span><span class="p">));</span>
<span class="linenos">208</span>
<span class="linenos">209</span><span class="w">    </span><span class="c1">// do_miss 标识是否请求被填充进 MSHR 或者 被放到 m_miss_queue 以在下一个周期</span>
<span class="linenos">210</span><span class="w">    </span><span class="c1">// 发送到下一级存储。</span>
<span class="linenos">211</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">do_miss</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">212</span><span class="w">      </span><span class="c1">// If evicted block is modified and not a write-through</span>
<span class="linenos">213</span><span class="w">      </span><span class="c1">// (already modified lower level)</span>
<span class="linenos">214</span><span class="w">      </span><span class="c1">// wb 变量标识 tag_array::access() 函数中，如果上面的 m_tag_array-&gt;access</span>
<span class="linenos">215</span><span class="w">      </span><span class="c1">// 函数发生 MISS，则需要逐出一个 block，并将这个 evicted block 写回到下一级</span>
<span class="linenos">216</span><span class="w">      </span><span class="c1">// 存储。如果这个 block 已经是 modified line，则 wb 为 true，因为在将其分配</span>
<span class="linenos">217</span><span class="w">      </span><span class="c1">// 给新访问之前，必须将这个已经 modified 的 block 写回到下一级存储。但如果这</span>
<span class="linenos">218</span><span class="w">      </span><span class="c1">// 个 block 是 clean line，则 wb 为 false，因为这个 block 不需要写回到下一</span>
<span class="linenos">219</span><span class="w">      </span><span class="c1">// 级存储。这个 evicted block 的信息被设置在 evicted 中。</span>
<span class="linenos">220</span><span class="w">      </span><span class="c1">// 这里如果 cache 的写策略为写直达，就不需要在读 miss 时将被逐出的 MODIFIED</span>
<span class="linenos">221</span><span class="w">      </span><span class="c1">// cache block 写回到下一级存储，因为这个 cache block 在被 MODIFIED 的时候</span>
<span class="linenos">222</span><span class="w">      </span><span class="c1">// 已经被 write-through 到下一级存储了。</span>
<span class="linenos">223</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wb</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_write_policy</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WRITE_THROUGH</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">224</span><span class="w">        </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_memfetch_creator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span>
<span class="linenos">225</span><span class="w">            </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">m_wrbk_type</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_warp_mask</span><span class="p">(),</span>
<span class="linenos">226</span><span class="w">            </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_byte_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_sector_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_modified_size</span><span class="p">,</span>
<span class="linenos">227</span><span class="w">            </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_tot_sim_cycle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_sim_cycle</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span>
<span class="linenos">228</span><span class="w">            </span><span class="nb">NULL</span><span class="p">);</span>
<span class="linenos">229</span><span class="w">        </span><span class="c1">// the evicted block may have wrong chip id when advanced L2 hashing  is</span>
<span class="linenos">230</span><span class="w">        </span><span class="c1">// used, so set the right chip address from the original mf</span>
<span class="linenos">231</span><span class="w">        </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_chip</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">chip</span><span class="p">);</span>
<span class="linenos">232</span><span class="w">        </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_partition</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">sub_partition</span><span class="p">);</span>
<span class="linenos">233</span><span class="w">        </span><span class="c1">// 写回 evicted block 到下一级存储。</span>
<span class="linenos">234</span><span class="w">        </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_BACK_REQUEST_SENT</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">),</span>
<span class="linenos">235</span><span class="w">                          </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">236</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">237</span><span class="w">      </span><span class="c1">// 整个写 MISS 处理函数的所有过程全部完成，返回的是 write miss 这个原始写请求</span>
<span class="linenos">238</span><span class="w">      </span><span class="c1">// 的状态。</span>
<span class="linenos">239</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">MISS</span><span class="p">;</span>
<span class="linenos">240</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">241</span><span class="w">    </span><span class="c1">// 整个写 MISS 处理函数没有分配新的 cache block，并将逐出的 block 写回，因此返</span>
<span class="linenos">242</span><span class="w">    </span><span class="c1">// 回 RESERVATION_FAIL。</span>
<span class="linenos">243</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">244</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">245</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="code-data-cache-wr-miss-wa-lazy-fetch-on-read">
<div class="code-block-caption"><span class="caption-number">列表 1.22 </span><span class="caption-text">data_cache::wr_miss_wa_lazy_fetch_on_read() 函数</span><a class="headerlink" href="#code-data-cache-wr-miss-wa-lazy-fetch-on-read" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">  0</span><span class="cm">/*</span>
<span class="linenos">  1</span><span class="cm">write_allocated_lazy_fetch_on_read 策略。</span>
<span class="linenos">  2</span><span class="cm">需要参考 https://arxiv.org/pdf/1810.07269.pdf 论文对 Volta 架构访存行为的解释。</span>
<span class="linenos">  3</span><span class="cm">L2 缓存应用了不同的写入分配策略，将其命名为延迟读取读取，这是写入验证和写入时读取</span>
<span class="linenos">  4</span><span class="cm">之间的折衷方案。当收到对已修改扇区的扇区读请求时，它首先检查扇区写掩码是否完整，即</span>
<span class="linenos">  5</span><span class="cm">所有字节均已写入并且该行完全可读。如果是，则读取该扇区；否则，与写入时读取类似，它</span>
<span class="linenos">  6</span><span class="cm">生成该扇区的读取请求并将其与修改后的字节合并。</span>
<span class="linenos">  7</span><span class="cm">*/</span>
<span class="linenos">  8</span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="nf">data_cache::wr_miss_wa_lazy_fetch_on_read</span><span class="p">(</span>
<span class="linenos">  9</span><span class="w">    </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time</span><span class="p">,</span>
<span class="linenos"> 10</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">cache_event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 11</span><span class="w">  </span><span class="c1">// m_config.block_addr(addr):</span>
<span class="linenos"> 12</span><span class="w">  </span><span class="c1">//     return addr &amp; ~(new_addr_type)(m_line_sz - 1);</span>
<span class="linenos"> 13</span><span class="w">  </span><span class="c1">// |-------|-------------|--------------|</span>
<span class="linenos"> 14</span><span class="w">  </span><span class="c1">//            set_index   offset in-line</span>
<span class="linenos"> 15</span><span class="w">  </span><span class="c1">// |&lt;--------tag--------&gt; 0 0 0 0 0 0 0 |</span>
<span class="linenos"> 16</span><span class="w">  </span><span class="n">new_addr_type</span><span class="w"> </span><span class="n">block_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">block_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="linenos"> 17</span>
<span class="linenos"> 18</span><span class="w">  </span><span class="c1">// if the request writes to the whole cache block/sector, then, write and set</span>
<span class="linenos"> 19</span><span class="w">  </span><span class="c1">// cache block Modified. and no need to send read request to memory or reserve</span>
<span class="linenos"> 20</span><span class="w">  </span><span class="c1">// mshr</span>
<span class="linenos"> 21</span>
<span class="linenos"> 22</span><span class="w">  </span><span class="c1">// FETCH_ON_READ policy: https://arxiv.org/pdf/1810.07269.pdf</span>
<span class="linenos"> 23</span><span class="w">  </span><span class="c1">// In literature, there are two different write allocation policies [32], fetch-</span>
<span class="linenos"> 24</span><span class="w">  </span><span class="c1">// on-write and write-validate. In fetch-on-write, when we write to a single byte</span>
<span class="linenos"> 25</span><span class="w">  </span><span class="c1">// of a sector, the L2 fetches the whole sector then merges the written portion</span>
<span class="linenos"> 26</span><span class="w">  </span><span class="c1">// to the sector and sets the sector as modified. In the write-validate policy,</span>
<span class="linenos"> 27</span><span class="w">  </span><span class="c1">// no read fetch is required, instead each sector has a bit-wise write-mask. When</span>
<span class="linenos"> 28</span><span class="w">  </span><span class="c1">// a write to a single byte is received, it writes the byte to the sector, sets</span>
<span class="linenos"> 29</span><span class="w">  </span><span class="c1">// the corresponding write bit and sets the sector as valid and modified. When a</span>
<span class="linenos"> 30</span><span class="w">  </span><span class="c1">// modified cache line is evicted, the cache line is written back to the memory</span>
<span class="linenos"> 31</span><span class="w">  </span><span class="c1">// along with the write mask. It is important to note that, in a write-validate</span>
<span class="linenos"> 32</span><span class="w">  </span><span class="c1">// policy, it assumes the read and write granularity can be in terms of bytes in</span>
<span class="linenos"> 33</span><span class="w">  </span><span class="c1">// order to exploit the benefits of the write-mask. In fact, based on our micro-</span>
<span class="linenos"> 34</span><span class="w">  </span><span class="c1">// benchmark shown in Figure 5, we have observed that the L2 cache applies some-</span>
<span class="linenos"> 35</span><span class="w">  </span><span class="c1">// thing similar to write-validate. However, all the reads received by L2 caches</span>
<span class="linenos"> 36</span><span class="w">  </span><span class="c1">// from the coalescer are 32-byte sectored accesses. Thus, the read access granu-</span>
<span class="linenos"> 37</span><span class="w">  </span><span class="c1">// larity (32 bytes) is different from the write access granularity (one byte).</span>
<span class="linenos"> 38</span><span class="w">  </span><span class="c1">// To handle this, the L2 cache applies a different write allocation policy,</span>
<span class="linenos"> 39</span><span class="w">  </span><span class="c1">// which we named lazy fetch-on-read, that is a compromise between write-validate</span>
<span class="linenos"> 40</span><span class="w">  </span><span class="c1">// and fetch-on-write. When a sector read request is received to a modified</span>
<span class="linenos"> 41</span><span class="w">  </span><span class="c1">// sector,it first checks if the sector write-mask is complete, i.e. all the</span>
<span class="linenos"> 42</span><span class="w">  </span><span class="c1">// bytes have been written to and the line is fully readable. If so, it reads</span>
<span class="linenos"> 43</span><span class="w">  </span><span class="c1">// the sector, otherwise, similar to fetch-on-write, it generates a read request</span>
<span class="linenos"> 44</span><span class="w">  </span><span class="c1">// for this sector and merges it with the modified bytes.</span>
<span class="linenos"> 45</span>
<span class="linenos"> 46</span><span class="w">  </span><span class="c1">// 若 m_miss_queue.size() 已经不能容下一个数据包的话，有可能无法完成后续动作，因</span>
<span class="linenos"> 47</span><span class="w">  </span><span class="c1">// 为后面最多需要执行一次 send_write_request，有可能最多需要向 m_miss_queue 添加</span>
<span class="linenos"> 48</span><span class="w">  </span><span class="c1">// 两个数据包。虽然后面代码里有两次 send_write_request，但是这两次是不会同时发</span>
<span class="linenos"> 49</span><span class="w">  </span><span class="c1">// 生。</span>
<span class="linenos"> 50</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">miss_queue_full</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 51</span><span class="w">    </span><span class="n">m_stats</span><span class="p">.</span><span class="n">inc_fail_stats</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_type</span><span class="p">(),</span><span class="w"> </span><span class="n">MISS_QUEUE_FULL</span><span class="p">);</span>
<span class="linenos"> 52</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span><span class="w">  </span><span class="c1">// cannot handle request this cycle</span>
<span class="linenos"> 53</span><span class="w">  </span><span class="p">}</span>
<span class="linenos"> 54</span>
<span class="linenos"> 55</span><span class="w">  </span><span class="c1">// 在 V100 配置中，L1 cache 为 &#39;T&#39;-write through，L2 cache 为 &#39;B&#39;-write back。</span>
<span class="linenos"> 56</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_write_policy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">WRITE_THROUGH</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 57</span><span class="w">    </span><span class="c1">// 如果是 write through，则需要直接将数据一同写回下一层存储。将数据写请求一同发</span>
<span class="linenos"> 58</span><span class="w">    </span><span class="c1">// 送至下一级存储。这里需要做的是将读请求类型 WRITE_REQUEST_SENT 放入 events，</span>
<span class="linenos"> 59</span><span class="w">    </span><span class="c1">// 并将数据请求 mf 放入当前 cache 的 m_miss_queue 中，等待 baseline_cache::</span>
<span class="linenos"> 60</span><span class="w">    </span><span class="c1">// cycle() 将队首的数据请求 mf 发送给下一级存储。</span>
<span class="linenos"> 61</span><span class="w">    </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_REQUEST_SENT</span><span class="p">),</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos"> 62</span><span class="w">  </span><span class="p">}</span>
<span class="linenos"> 63</span>
<span class="linenos"> 64</span><span class="w">  </span><span class="c1">// wb 变量标识 tag_array::access() 函数中，如果下面的 send_read_request 函数发</span>
<span class="linenos"> 65</span><span class="w">  </span><span class="c1">// 生 MISS，则需要逐出一个 block，并将这个 evicted block 写回到下一级存储。如果</span>
<span class="linenos"> 66</span><span class="w">  </span><span class="c1">// 这个 block 已经是 modified line，则 wb 为 true，因为在将其分配给新访问之前，</span>
<span class="linenos"> 67</span><span class="w">  </span><span class="c1">// 必须将这个已经 modified 的 block 写回到下一级存储。但如果这个 block 是 clean</span>
<span class="linenos"> 68</span><span class="w">  </span><span class="c1">// line，则 wb 为 false，因为这个 block 不需要写回到下一级存储。这个 evicted</span>
<span class="linenos"> 69</span><span class="w">  </span><span class="c1">// block 的信息被设置在 evicted 中。</span>
<span class="linenos"> 70</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos"> 71</span><span class="w">  </span><span class="c1">// evicted 记录着被逐出的 cache block 的信息。</span>
<span class="linenos"> 72</span><span class="w">  </span><span class="n">evicted_block_info</span><span class="w"> </span><span class="n">evicted</span><span class="p">;</span>
<span class="linenos"> 73</span><span class="w">  </span><span class="c1">// 更新 tag_array 的状态，包括更新 LRU 状态，设置逐出的 block 或 sector 等。</span>
<span class="linenos"> 74</span><span class="w">  </span><span class="n">cache_request_status</span><span class="w"> </span><span class="n">m_status</span><span class="w"> </span><span class="o">=</span>
<span class="linenos"> 75</span><span class="w">      </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">cache_index</span><span class="p">,</span><span class="w"> </span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 76</span>
<span class="linenos"> 77</span><span class="w">  </span><span class="c1">// Theoretically, the passing parameter status should be the same as the</span>
<span class="linenos"> 78</span><span class="w">  </span><span class="c1">// m_status, if the assertion fails here, go to function `wr_miss_wa_lazy</span>
<span class="linenos"> 79</span><span class="w">  </span><span class="c1">// _fetch_on_read` to remove this assertion.</span>
<span class="linenos"> 80</span><span class="w">  </span><span class="c1">// assert((m_status == status));</span>
<span class="linenos"> 81</span><span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">m_status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">HIT</span><span class="p">);</span>
<span class="linenos"> 82</span><span class="w">  </span><span class="c1">// cache_index 是 cache block 的 index。</span>
<span class="linenos"> 83</span><span class="w">  </span><span class="n">cache_block_t</span><span class="w"> </span><span class="o">*</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">get_block</span><span class="p">(</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos"> 84</span><span class="w">  </span><span class="c1">// 如果 block 不是 modified line，则增加 dirty 计数。因为如果这个时候 block 不</span>
<span class="linenos"> 85</span><span class="w">  </span><span class="c1">// 是 modified line，说明这个 block 是 clean line，而现在要写入数据，因此需要将</span>
<span class="linenos"> 86</span><span class="w">  </span><span class="c1">// 这个 block 设置为 modified line。这样的话，dirty 计数就需要增加。但若 block</span>
<span class="linenos"> 87</span><span class="w">  </span><span class="c1">// 已经是 modified line，则不需要增加 dirty 计数，这个 block 在上次变成 dirty</span>
<span class="linenos"> 88</span><span class="w">  </span><span class="c1">// 的时候，dirty 计数已经增加过了。</span>
<span class="linenos"> 89</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_modified_line</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 90</span><span class="w">    </span><span class="n">m_tag_array</span><span class="o">-&gt;</span><span class="n">inc_dirty</span><span class="p">();</span>
<span class="linenos"> 91</span><span class="w">  </span><span class="p">}</span>
<span class="linenos"> 92</span><span class="w">  </span><span class="c1">// 设置 block 的状态为 modified，即将 block 设置为 MODIFIED。这样的话，下次再</span>
<span class="linenos"> 93</span><span class="w">  </span><span class="c1">// 有数据请求访问这个 block 的时候，就可以直接从 cache 中读取数据，而不需要再次</span>
<span class="linenos"> 94</span><span class="w">  </span><span class="c1">// 访问下一级存储。</span>
<span class="linenos"> 95</span><span class="w">  </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_status</span><span class="p">(</span><span class="n">MODIFIED</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos"> 96</span><span class="w">  </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_byte_mask</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="linenos"> 97</span><span class="w">  </span><span class="c1">// 如果 Cache block[mask] 状态是 RESERVED，说明有其他的线程正在读取这个 Cache</span>
<span class="linenos"> 98</span><span class="w">  </span><span class="c1">// block。挂起的命中访问已命中处于 RESERVED 状态的缓存行，这意味着同一行上已存在</span>
<span class="linenos"> 99</span><span class="w">  </span><span class="c1">// 由先前缓存未命中发送的 flying 内存请求。</span>
<span class="linenos">100</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">HIT_RESERVED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">101</span><span class="w">    </span><span class="c1">// 在当前版本的 GPGPU-Sim 中，set_ignore_on_fill 暂时用不到。</span>
<span class="linenos">102</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_ignore_on_fill</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">103</span><span class="w">    </span><span class="c1">// cache block 的每个 sector 都有一个标志位 m_set_modified_on_fill[i]，标记</span>
<span class="linenos">104</span><span class="w">    </span><span class="c1">// 着这个 cache block 是否被修改，在sector_cache_block::fill() 函数调用的时</span>
<span class="linenos">105</span><span class="w">    </span><span class="c1">// 候会使用。</span>
<span class="linenos">106</span><span class="w">    </span><span class="c1">// 将 block 设置为在下次 fill 时，置为 MODIFIED。这样的话，下次再有数据请求填</span>
<span class="linenos">107</span><span class="w">    </span><span class="c1">// 入 fill 时：</span>
<span class="linenos">108</span><span class="w">    </span><span class="c1">//   m_status = m_set_modified_on_fill ? MODIFIED : VALID; 或</span>
<span class="linenos">109</span><span class="w">    </span><span class="c1">//   m_status[sidx] = m_set_modified_on_fill[sidx] ? MODIFIED : VALID;</span>
<span class="linenos">110</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_modified_on_fill</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">111</span><span class="w">    </span><span class="c1">// 在 FETCH_ON_READ policy: https://arxiv.org/pdf/1810.07269.pdf 中提到，</span>
<span class="linenos">112</span><span class="w">    </span><span class="c1">// 访问 cache 发生 miss 时：</span>
<span class="linenos">113</span><span class="w">    </span><span class="c1">// In the write-validate policy, no read fetch is required, instead each</span>
<span class="linenos">114</span><span class="w">    </span><span class="c1">// sector has a bit-wise write-mask. When a write to a single byte is</span>
<span class="linenos">115</span><span class="w">    </span><span class="c1">// received, it writes the byte to the sector, sets the corresponding</span>
<span class="linenos">116</span><span class="w">    </span><span class="c1">// write bit and sets the sector as valid and modified. When a modified</span>
<span class="linenos">117</span><span class="w">    </span><span class="c1">// cache line is evicted, the cache line is written back to the memory</span>
<span class="linenos">118</span><span class="w">    </span><span class="c1">// along with the write mask.</span>
<span class="linenos">119</span><span class="w">    </span><span class="c1">// 而在 FETCH_ON_READ 中，需要设置 sector 的 byte mask。这里就是指设置这个</span>
<span class="linenos">120</span><span class="w">    </span><span class="c1">// byte mask 的标志。</span>
<span class="linenos">121</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_byte_mask_on_fill</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="linenos">122</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">123</span>
<span class="linenos">124</span><span class="w">  </span><span class="c1">// m_config.get_atom_sz() 为 SECTOR_SIZE = 4，即 mf 访问的是一整个 4 字节。</span>
<span class="linenos">125</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_byte_mask</span><span class="p">().</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m_config</span><span class="p">.</span><span class="n">get_atom_sz</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">126</span><span class="w">    </span><span class="c1">// 由于 mf 访问的是整个 sector，因此整个 sector 都是 dirty 的，设置访问的</span>
<span class="linenos">127</span><span class="w">    </span><span class="c1">// sector 可读。</span>
<span class="linenos">128</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_m_readable</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">129</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">130</span><span class="w">    </span><span class="c1">// 由于 mf 访问的是部分 sector，因此只有 mf 访问的那部分 sector 是 dirty 的，</span>
<span class="linenos">131</span><span class="w">    </span><span class="c1">// 设置访问的 sector 不可读。但是设置在下次这个 sector 被 fill 时，mf-&gt;get_</span>
<span class="linenos">132</span><span class="w">    </span><span class="c1">// access_sector_mask() 标识的 byte 置为 MODIFIED。</span>
<span class="linenos">133</span><span class="w">    </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_m_readable</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">134</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">HIT_RESERVED</span><span class="p">)</span>
<span class="linenos">135</span><span class="w">      </span><span class="n">block</span><span class="o">-&gt;</span><span class="n">set_readable_on_fill</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_sector_mask</span><span class="p">());</span>
<span class="linenos">136</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">137</span><span class="w">  </span><span class="c1">// 更新一个 cache block 的状态为可读。如果所有的 byte mask 位全都设置为 dirty</span>
<span class="linenos">138</span><span class="w">  </span><span class="c1">// 了，则将该 sector 可设置为可读，因为当前的 sector 已经是全部更新为最新值了，</span>
<span class="linenos">139</span><span class="w">  </span><span class="c1">// 是可读的。这个函数对所有的数据请求 mf 的所有访问的 sector 进行遍历，如果 mf</span>
<span class="linenos">140</span><span class="w">  </span><span class="c1">// 所访问的所有的 byte mask 位全都设置为 dirty 了，则将该 cache block 设置为可</span>
<span class="linenos">141</span><span class="w">  </span><span class="c1">// 读。</span>
<span class="linenos">142</span><span class="w">  </span><span class="n">update_m_readable</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">cache_index</span><span class="p">);</span>
<span class="linenos">143</span>
<span class="linenos">144</span><span class="w">  </span><span class="c1">// 只要 m_tag_array-&gt;access 返回的状态不是 RESERVATION_FAIL，就说明或者发生了</span>
<span class="linenos">145</span><span class="w">  </span><span class="c1">// HIT_RESERVED，或者 SECTOR_MISS，又或者 MISS。这里只要不是 RESERVATION_FAIL，</span>
<span class="linenos">146</span><span class="w">  </span><span class="c1">// 就代表有 cache block 被分配了，因此要根据这个被逐出的 cache block 是否需要写</span>
<span class="linenos">147</span><span class="w">  </span><span class="c1">// 回，将这个 block 写回到下一级存储。</span>
<span class="linenos">148</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">149</span><span class="w">    </span><span class="c1">// If evicted block is modified and not a write-through</span>
<span class="linenos">150</span><span class="w">    </span><span class="c1">// (already modified lower level)</span>
<span class="linenos">151</span><span class="w">    </span><span class="c1">// wb 变量标识 tag_array::access() 函数中，如果上面的 m_tag_array-&gt;access</span>
<span class="linenos">152</span><span class="w">    </span><span class="c1">// 函数发生 MISS，则需要逐出一个 block，并将这个 evicted block 写回到下一级</span>
<span class="linenos">153</span><span class="w">    </span><span class="c1">// 存储。如果这个 block 已经是 modified line，则 wb 为 true，因为在将其分配</span>
<span class="linenos">154</span><span class="w">    </span><span class="c1">// 给新访问之前，必须将这个已经 modified 的 block 写回到下一级存储。但如果这</span>
<span class="linenos">155</span><span class="w">    </span><span class="c1">// 个 block 是 clean line，则 wb 为 false，因为这个 block 不需要写回到下一</span>
<span class="linenos">156</span><span class="w">    </span><span class="c1">// 级存储。这个 evicted block 的信息被设置在 evicted 中。</span>
<span class="linenos">157</span><span class="w">    </span><span class="c1">// 这里如果 cache 的写策略为写直达，就不需要在读 miss 时将被逐出的 MODIFIED</span>
<span class="linenos">158</span><span class="w">    </span><span class="c1">// cache block 写回到下一级存储，因为这个 cache block 在被 MODIFIED 的时候</span>
<span class="linenos">159</span><span class="w">    </span><span class="c1">// 已经被 write-through 到下一级存储了。</span>
<span class="linenos">160</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wb</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">m_write_policy</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WRITE_THROUGH</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">161</span><span class="w">      </span><span class="n">mem_fetch</span><span class="w"> </span><span class="o">*</span><span class="n">wb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_memfetch_creator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span>
<span class="linenos">162</span><span class="w">          </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_block_addr</span><span class="p">,</span><span class="w"> </span><span class="n">m_wrbk_type</span><span class="p">,</span><span class="w"> </span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_access_warp_mask</span><span class="p">(),</span>
<span class="linenos">163</span><span class="w">          </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_byte_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_sector_mask</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">.</span><span class="n">m_modified_size</span><span class="p">,</span>
<span class="linenos">164</span><span class="w">          </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_tot_sim_cycle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_gpu</span><span class="o">-&gt;</span><span class="n">gpu_sim_cycle</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span>
<span class="linenos">165</span><span class="w">          </span><span class="nb">NULL</span><span class="p">);</span>
<span class="linenos">166</span><span class="w">      </span><span class="c1">// the evicted block may have wrong chip id when advanced L2 hashing  is</span>
<span class="linenos">167</span><span class="w">      </span><span class="c1">// used, so set the right chip address from the original mf</span>
<span class="linenos">168</span><span class="w">      </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_chip</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">chip</span><span class="p">);</span>
<span class="linenos">169</span><span class="w">      </span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">set_partition</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">get_tlx_addr</span><span class="p">().</span><span class="n">sub_partition</span><span class="p">);</span>
<span class="linenos">170</span><span class="w">      </span><span class="c1">// 写回 evicted block 到下一级存储。</span>
<span class="linenos">171</span><span class="w">      </span><span class="n">send_write_request</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span><span class="w"> </span><span class="n">cache_event</span><span class="p">(</span><span class="n">WRITE_BACK_REQUEST_SENT</span><span class="p">,</span><span class="w"> </span><span class="n">evicted</span><span class="p">),</span>
<span class="linenos">172</span><span class="w">                        </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">);</span>
<span class="linenos">173</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">174</span><span class="w">    </span><span class="c1">// 整个写 MISS 处理函数的所有过程全部完成，返回的是 write miss 这个原始写请求</span>
<span class="linenos">175</span><span class="w">    </span><span class="c1">// 的状态。</span>
<span class="linenos">176</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MISS</span><span class="p">;</span>
<span class="linenos">177</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">178</span><span class="w">  </span><span class="c1">// 整个写 MISS 处理函数没有分配新的 cache block，并将逐出的 block 写回，因此返</span>
<span class="linenos">179</span><span class="w">  </span><span class="c1">// 回 RESERVATION_FAIL。</span>
<span class="linenos">180</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RESERVATION_FAIL</span><span class="p">;</span>
<span class="linenos">181</span><span class="p">}</span>
</pre></div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="../index.html" class="btn btn-neutral float-left" title="Welcome to GPGPU-Sim User Manual’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 Copyright © 2024 MASA-Laboratory &lt;masa-lab@outlook.com&gt;。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>